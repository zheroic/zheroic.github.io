<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>spark内存计算-1</title>
      <link href="/2019/09/26/spark-1/"/>
      <url>/2019/09/26/spark-1/</url>
      
        <content type="html"><![CDATA[<h1 id="初始spark"><a href="#初始spark" class="headerlink" title="初始spark"></a>初始spark</h1><h2 id="大数据技术框架"><a href="#大数据技术框架" class="headerlink" title="大数据技术框架"></a>大数据技术框架</h2><p><img alt="大数据技术框架-1" data-src="https://pic.superbed.cn/item/5d8c7975451253d178dc6217.png" class="lozad"><br><img alt="大数据技术框架-2" data-src="https://pic.superbed.cn/item/5d8c7b5f451253d178dcdca7.png" class="lozad"><br><img alt="大数据技术框架-3" data-src="https://pic.superbed.cn/item/5d8c7bc2451253d178dcf470.png" class="lozad"></p><h2 id="spark背景-HDFS"><a href="#spark背景-HDFS" class="headerlink" title="spark背景-HDFS"></a>spark背景-HDFS</h2><h3 id="官方定义："><a href="#官方定义：" class="headerlink" title="官方定义："></a>官方定义：</h3><p>分布式存储系统HDFS（Hadoop Distributed File System）。<br>其实就是一个文件系统，类似于linux的文件系统。有目录，目录下可以存储文件。但它又是一个分布式的文件系统。</p><h3 id="基本原理："><a href="#基本原理：" class="headerlink" title="基本原理："></a>基本原理：</h3><ul><li>将文件切分成等大的数据块。分别存储到多台机器上。</li><li>每个数据块存在多个备份。</li><li>将数据切分、容错、负载均衡等功能透明化。</li><li>可将HDFS看成是一个巨大、具有容错性的磁盘。<br><img alt="HDFS架构" data-src="https://pic.superbed.cn/item/5d8c8f8d451253d178e227b1.png" class="lozad"></li></ul><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul><li>处理超大文件</li><li>流式的数据访问</li><li>运行于廉价的商业机器集群上</li></ul><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul><li>不适合存储大量小文件</li><li>不适合低延迟数据访问</li><li>不支持多用户写入及任意修改文件</li></ul><h2 id="spark背景-资源调度"><a href="#spark背景-资源调度" class="headerlink" title="spark背景-资源调度"></a>spark背景-资源调度</h2><ul><li>Hadoop2.0提出的资源管理层</li><li>用于集群资源管理和应用调度</li><li>使得多种计算框架可以运行在一个集群中</li><li>mapreduce仅仅是Yarn的一种应用模式</li></ul><h2 id="spark背景-Mapreduce"><a href="#spark背景-Mapreduce" class="headerlink" title="spark背景-Mapreduce"></a>spark背景-Mapreduce</h2><p>一个大数据若可以分为具有相同计算过程的数据块，并且这些数据块之间<strong>不存在数据依赖</strong>关系，则提高处理速度的最好方法就是<strong>并行计算</strong>。<br>Master：负责划分和分配任务<br>Worker：负责数据块计算</p><h3 id="为什么需要？"><a href="#为什么需要？" class="headerlink" title="为什么需要？"></a>为什么需要？</h3><ul><li>并行计算技术和并行程序设计的复杂性</li><li>海量数据处理需要有效的并行处理技术</li><li>MapReduce是面向海量数据比较成功的技术</li></ul><h3 id="大规模数据处理时，MapReduce在三个层次上的基本构思："><a href="#大规模数据处理时，MapReduce在三个层次上的基本构思：" class="headerlink" title="大规模数据处理时，MapReduce在三个层次上的基本构思："></a>大规模数据处理时，MapReduce在三个层次上的基本构思：</h3><p>1.如何对付大数据处理：分而治之<br>2.上升到抽象模型：Mapper与Reducer<br>3.上升到构架：统一构架，为程序员隐藏系统层细节</p><h3 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h3><p><strong>不可分拆的计算任务或者相互间有依赖关系的数据无法进行并行计算！</strong></p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><pre class=" language-C++"><code class="language-C++">public static class Map extends Mapper<object,text,text,intwritable>{    //one表示单词只出现一次    private static IntWriteable one = new IntWritable(1);    //word存储切下的单词    private Text word = new Text();    public void map(Object key,Text value,Context context) throw IOException,InterruptedException{        //对输入的行切词        StringTokenizer st = new StringTokenizer(value.toString());        while(st.hasMoreTokens()) {            word.set(st.nextToken());//切下的单词存入word            context.write(word,one);        }    }}</object,text,text,intwritable></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> spark内存计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件需求分析设计-2</title>
      <link href="/2019/09/25/software-requirement-2/"/>
      <url>/2019/09/25/software-requirement-2/</url>
      
        <content type="html"><![CDATA[<h1 id="软件需求分析设计"><a href="#软件需求分析设计" class="headerlink" title="软件需求分析设计"></a>软件需求分析设计</h1><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="需求调研-获取："><a href="#需求调研-获取：" class="headerlink" title="需求调研/获取："></a>需求调研/获取：</h3><p>1.需求获取的重要性：最关键、最困难、最易出错、最需要交流<br>2.需求获取的前提条件： 领域知识（业务知识）、沟通能力</p><h3 id="需求：是产品必须完成的事（功能性需求）以及必须具备的品质"><a href="#需求：是产品必须完成的事（功能性需求）以及必须具备的品质" class="headerlink" title="需求：是产品必须完成的事（功能性需求）以及必须具备的品质"></a>需求：是产品必须完成的事（功能性需求）以及必须具备的品质</h3><p>1.需要的东西：需求形式（样式风格）、数据信息、需求的内容<br>2.需求的种类：<br>    - 功能性需求：系统应该做的<br>    - 非功能性需求：质量+约束，系统特定的特性或约束<br>3.需求层次：<br>    - 业务需求<br>        - 反映了组织结构或客户队系统产品高层次的目标要求<br>        - 业务目标：系统建设目标<br>    - 用户需求<br>        - 描述了用户使用产品必须完成的任务<br>    - 功能需求（软件需求）<br>        - 定义开发人员必须实现的软件功能，使得用户能完成他们的任务，从而满足业务需求<br>    - 技术需求（具体的实现细节）<br>4.需求分析极致目的：所有人做的都一样</p><h3 id="项目中标："><a href="#项目中标：" class="headerlink" title="项目中标："></a>项目中标：</h3><p>中标前：项目应标成功<br>    - 获取的要素：业务需求和用户需求 (全面性)<br>中标后：确定项目范围<br>    - 要点：全部用户需求、部分功能需求</p><h3 id="需求获取："><a href="#需求获取：" class="headerlink" title="需求获取："></a>需求获取：</h3><p>1.需求获取定义：<br>是通过客户、系统用户和其他与系统开发相关的人员交流发现系统需求的过程，是一个确定和理解不同用户种类的需要和限制的过程<br>2.需求获取总原则：<br>    - 先获取系统的总体目标（宏观）（业务需求）<br>    - 接着获取当前工作以及当前问题的信息（中观）（用户需求）<br>    - 然后系统应先处理的详细问题（微观）（用户需求）<br>3.需求获取第一步：<br>相关人员分析：是指那些直接或间接从开发的系统中受益的人、发现所有可能的需求源<br>4.需求获取前的准备：<br>明确问题清单（调研提纲）<br>    - 问题类型：封闭性问题、开放性问题<br>5.需求获取技术：<br>    - 访谈（领域知识、沟通能力）<br>    - 问卷调查（半封闭性问题：问卷设计（问题）、小范围验证）<br>    - 观察（演示）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件需求分析设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件需求分析设计-1</title>
      <link href="/2019/09/25/software-requirement-1/"/>
      <url>/2019/09/25/software-requirement-1/</url>
      
        <content type="html"><![CDATA[<h1 id="软件需求分析设计"><a href="#软件需求分析设计" class="headerlink" title="软件需求分析设计"></a>软件需求分析设计</h1><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="项目："><a href="#项目：" class="headerlink" title="项目："></a>项目：</h3><p>为创建一个独特产品、服务或任务所做的临时性努力</p><h3 id="软件开发通用技术："><a href="#软件开发通用技术：" class="headerlink" title="软件开发通用技术："></a>软件开发通用技术：</h3><p>1.抽象技术<br>2.分解技术<br>3.形式化表达（模型/模式、传播）<br>4.封装  </p><h3 id="软件开发方法："><a href="#软件开发方法：" class="headerlink" title="软件开发方法："></a>软件开发方法：</h3><p>1.结构化方法<br>2.面向对象方法：<br>    - 面向过程<br>    - 面向对象<br>    - 面向数据<br>    - 面向服务<br>    - 面向控制<br>面向对象和结构化方法的区别：<br>    - 面向对象按照对象和概念分解<br>    - 结构化方法按照过程和功能分解<br>    功能：抽象：抽取共性、抛弃不同特性的过程<br>面向对象的核心是面向接口<br>面向对象：可维护、可复用、可扩展、灵活性好</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件需求分析设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hadoop环境配置</title>
      <link href="/2019/09/25/hadoop-1/"/>
      <url>/2019/09/25/hadoop-1/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>data-science</title>
      <link href="/2019/09/24/data-science/"/>
      <url>/2019/09/24/data-science/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据科学导论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux基础</title>
      <link href="/2019/09/23/linux-basic/"/>
      <url>/2019/09/23/linux-basic/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人月神话第三章：外科手术队伍</title>
      <link href="/2019/09/17/man-month-thirdchapter/"/>
      <url>/2019/09/17/man-month-thirdchapter/</url>
      
        <content type="html"><![CDATA[<p><img alt="外科手术现场" data-src="https://pic.superbed.cn/item/5d80cb26451253d1784b34c8.jpg" class="lozad"></p><h1 id="外科手术队伍"><a href="#外科手术队伍" class="headerlink" title="外科手术队伍"></a>外科手术队伍</h1><p>如何在有意义的进度安排内创建大型的系统？</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>协调矛盾： 对于效率和概念的完整性来说，最好由少数干练的人员来开发设计；对于大型系统来说，则需要大量的人手，以使产品能在时间上满足要求，怎么才能协调两者之间的矛盾？</p><h2 id="Mills的建议"><a href="#Mills的建议" class="headerlink" title="Mills的建议"></a>Mills的建议</h2><h4 id="10人编程团队："><a href="#10人编程团队：" class="headerlink" title="10人编程团队："></a>10人编程团队：</h4><h5 id="首席程序员（外科医生）："><a href="#首席程序员（外科医生）：" class="headerlink" title="首席程序员（外科医生）："></a>首席程序员（外科医生）：</h5><p>亲自定义功能和性能技术说明书，设计程序，编写源代码，测试以及书写技术文档。</p><h5 id="副手："><a href="#副手：" class="headerlink" title="副手："></a>副手：</h5><p>是外科医生的后备，能够完成任何一部分工作，但是相对经验较少。主要作为设计的思考者、讨论者和评估者。充当外科医生的保险机制。</p><h5 id="管理员："><a href="#管理员：" class="headerlink" title="管理员："></a>管理员：</h5><p>控制财务、人员、工作地点、办公设备的专业人才。</p><h5 id="编辑："><a href="#编辑：" class="headerlink" title="编辑："></a>编辑：</h5><p>根据外科医生的口述或草稿，进行分析和重新组织，提供各种参考信息和书目，对多个版本进行维护，并监督文档生成的机制。</p><h5 id="两个文秘："><a href="#两个文秘：" class="headerlink" title="两个文秘："></a>两个文秘：</h5><p>管理员和编辑都需要。</p><h5 id="程序职员："><a href="#程序职员：" class="headerlink" title="程序职员："></a>程序职员：</h5><p>负责编程产品库中所有团队的技术记录。</p><h5 id="工具维护人员："><a href="#工具维护人员：" class="headerlink" title="工具维护人员："></a>工具维护人员：</h5><h5 id="测试人员："><a href="#测试人员：" class="headerlink" title="测试人员："></a>测试人员：</h5><p>负责计划测试步骤等等</p><h5 id="语言专家："><a href="#语言专家：" class="headerlink" title="语言专家："></a>语言专家：</h5><p>掌握复杂语言</p><p>向所有团队成员展示所有计算机的运行和产物，并将所有的程序和数据看作是团队的所有物，而不是私有财产。Mills观念的关键在于：从个人艺术到公共实践。</p><h2 id="如何运作"><a href="#如何运作" class="headerlink" title="如何运作"></a>如何运作</h2><p>首席程序员和副手都了解所有的设计和全部代码，节省了很大的劳动量，确保了工作概念的完整性。<br>观点不一致之处由首席程序员单方面统一，达到客观一致性。</p><h2 id="团队的扩建"><a href="#团队的扩建" class="headerlink" title="团队的扩建"></a>团队的扩建</h2><p>要有一个系统结构师从上之下进行所有的设计，必须清晰的划分体系结构设计和实现之间的界线。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 文字 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人月神话 </tag>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人月神话第二章：人月神话</title>
      <link href="/2019/09/17/man-month-secondchapter/"/>
      <url>/2019/09/17/man-month-secondchapter/</url>
      
        <content type="html"><![CDATA[<p><img alt="新奥尔良Antoine餐厅菜单" data-src="https://pic.superbed.cn/item/5d80afc8451253d1784737bd.jpg" class="lozad"></p><h1 id="人月神话"><a href="#人月神话" class="headerlink" title="人月神话"></a>人月神话</h1><p>项目滞后的最主要原因：<br>缺乏合理的进度安排。<br>（对估算技术缺乏有效的研究、<br>我们所采用的估算技术隐含的假设人和月可以互换，即时间与工作人员数量可以替换、<br>对自己的估算缺乏信心、<br>对进度缺少跟踪和监督、<br>当意识到进度偏移时，下意识以及传统的反应是增加人力，如同汽油灭火，注定导致灾难。）</p><h2 id="乐观主义"><a href="#乐观主义" class="headerlink" title="乐观主义"></a>乐观主义</h2><p>所有编程人员都是乐观主义者。无论什么程序，结果都是毋庸置疑的：“这次它肯定能够运行”、“我刚刚找出了最后一个错误”。<br>导致了系统编程的进度安排背后的第一个错误的假设是：一切都将运作良好，每一项任务仅花费它所“应该”花费的时间。<br>《创造者思想》将创造性活动分为：构思、实现、交流。<br>正是由于介质的易于驾驭，我们期待在实现过程钟不会遇到困难，因此造成了乐观主义的弥漫。但我们的构思又是有缺陷的，总会发现bug。所以我们的乐观主义不该是理所当然的。</p><h2 id="人月"><a href="#人月" class="headerlink" title="人月"></a>人月</h2><p>第二个错误的思考方式是在估计和进度安排钟使用的工作量单位：人月，认为人数和时间可以互换。<br>但这种思想仅适用于某个任务可以分解为若干个小任务，且他们之间不需要任何交流。而这在编程过程中几乎不可能实现。<br>软件开发本质上是一项系统工作：错综复杂关系下的一种实践，沟通、交流的工作量非常大，它会很快分解任务分解所节省下来的个人时间。因此，增加更多的人手，实际上是延长了而不是缩短了时间进度。</p><h2 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h2><p>理论上，缺陷的数量应该为0，但是由于我们的乐观主义，实际上出现的缺陷数量要远远多于预料中的数量。因此，系统测试进度的安排往往是编程中最不合理的部分。<br>brooks经验法则:<br>1/3计划<br>1/6编码<br>1/4构建测试和早期系统测试<br>1/4系统测试，所有构件已完成</p><h2 id="空泛的估算"><a href="#空泛的估算" class="headerlink" title="空泛的估算"></a>空泛的估算</h2><p>某项人物的计划进度，可能受限于顾客要求的紧迫程度，但紧迫程度无法控制实际的进度。<br>两种解决方案：<br>开发推行生产率图表、缺陷率图表、估算规则等等；<br>或者，在可靠的估算出现前，项目经理坚持他们的估计。</p><h2 id="重复产生的进度灾难"><a href="#重复产生的进度灾难" class="headerlink" title="重复产生的进度灾难"></a>重复产生的进度灾难</h2><p>Brooks法则：<br>向进度落后的项目增加人手，只会使进度更加落后。</p><h5 id="除去了神话色彩的人月。项目的时间依赖于顺序上的限制，人员的最大数量依赖于独立子任务的数量。"><a href="#除去了神话色彩的人月。项目的时间依赖于顺序上的限制，人员的最大数量依赖于独立子任务的数量。" class="headerlink" title="除去了神话色彩的人月。项目的时间依赖于顺序上的限制，人员的最大数量依赖于独立子任务的数量。"></a>除去了神话色彩的人月。项目的时间依赖于顺序上的限制，人员的最大数量依赖于独立子任务的数量。</h5><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 文字 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人月神话 </tag>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人月神话第一章：焦油坑</title>
      <link href="/2019/09/17/man-month-firstchapter/"/>
      <url>/2019/09/17/man-month-firstchapter/</url>
      
        <content type="html"><![CDATA[<p><img alt="拉布雷阿的焦油坑壁画" data-src="https://pic.superbed.cn/item/5d8062b9451253d1783e6769.jpg" class="lozad"></p><h1 id="焦油坑"><a href="#焦油坑" class="headerlink" title="焦油坑"></a>焦油坑</h1><p>程序开发就好像是一个焦油坑，很多很多人在挣扎，却是无法摆脱束缚，避免沉到坑底的命运。</p><h2 id="编程系统产品"><a href="#编程系统产品" class="headerlink" title="编程系统产品"></a>编程系统产品</h2><p>单单讲编程一个程序并不难,但要将它转化为更有用的，则需要投入几倍的成本来达到。</p><h2 id="编程乐趣"><a href="#编程乐趣" class="headerlink" title="编程乐趣"></a>编程乐趣</h2><p>   它是一种创建事物的纯粹快乐，这种快乐是上帝创造世界的折射，一种呈现在每片独特的、崭新<br>的树叶和雪花上的喜悦。<br>   快乐还来源于我们是开发出对别人有用的东西。内心深处，我们渴望着我们的劳动成果被其他人<br>认同、使用。<br>   快乐来自于将互相啮合的零部件组合在一起，看它们精妙运行的成就感。<br>   这种快乐还是持续学习的快乐。我们面临的问题总是不尽相同的，可以在解决问题的过程中不断<br>学习到新的知识。<br>   最后，快乐还来自于我们是在一种极易驾驭的介质上工作。我们几乎可以完全凭借自己的想象，<br>来搭建自己快乐“城堡”。<br>   我们在键盘上键入不同的咒语，屏幕上就会活动，变化，呈现出前所未有的不可能存在的事物，<br>编程满足了我们内心深处的创造欲。</p><h2 id="编程苦恼"><a href="#编程苦恼" class="headerlink" title="编程苦恼"></a>编程苦恼</h2><p>   我们追求完美。我们将做事的方向不断向完美调整。<br>   由他人设定目标，供给资源，提供信息。我们依赖别人的程序，即使那些程序设计并不合理。<br>   不断修正，寻找bug。十分的枯燥乏味。<br>   苦恼抑或是无奈。当一个项目将要完成时，有可能已经过时，不再适合当下。</p><h5 id="这就是编程，令人痛苦挣扎的焦油坑，一种乐趣与苦恼共存的活动。"><a href="#这就是编程，令人痛苦挣扎的焦油坑，一种乐趣与苦恼共存的活动。" class="headerlink" title="这就是编程，令人痛苦挣扎的焦油坑，一种乐趣与苦恼共存的活动。"></a>这就是编程，令人痛苦挣扎的焦油坑，一种乐趣与苦恼共存的活动。</h5><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 文字 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人月神话 </tag>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>木心先生诗选</title>
      <link href="/2019/09/11/muxin/"/>
      <url>/2019/09/11/muxin/</url>
      
        <content type="html"><![CDATA[<p>1</p><p>很多人的失落，是违背了自己少年时的立志。自认为成熟、自认为练达、自认为精明，从前多幼稚，总算看透了、想穿了。于是，我们就此变成自己年少时最憎恶的那种人。</p><p>——木心 《鱼丽之宴》</p><p>（不远千里多年，赴一个本不忍的约会……）</p><p>2</p><p>万头攒动火树银花之处不必找我。如欲相见，我在各种悲喜交集处，能做的只是长途跋涉的归真返璞。</p><p>——木心 《我纷纷的情欲》</p><p>（人间至色是素淡，人间至味是清欢）</p><p>3</p><p>看清世界荒谬，是一个智者的基本水准。看清了，不是感到恶心，而是会心一笑。</p><p>——木心</p><p>（暗暗摇头，三两声笑）</p><p>4</p><p>生命好在无意义，才容得下各自赋予意义。假如生命是有意义的，这个意义却不合我的志趣，那才尴尬狼狈。</p><p>——木心 《素履之往》</p><p>（无径自取径，苦也是我的苦，纵苦也欢愉）</p><p>5</p><p>有人说，时间是最妙的疗伤药。此话没说对，反正时间不是药，药在时间里。</p><p>——木心 《艾华利好兄弟》</p><p>（总之，时间还是治愈的……）</p><p>6</p><p>无知的人总是薄情的。无知的本质，就是薄情。</p><p>——木心 《文学回忆录》</p><p>（已是浅薄心，无处放深情）</p><p>7</p><p>昨天我和她坐在街头的喷泉边，五月的天气已很热了，刚买来的一袋樱桃也不好吃，我们抽着烟，“应该少抽烟才对”。</p><p>满街的人来来往往，她信口叹问：“生命是什么呵？”我脱口答道：“生命是时时刻刻不知如何是好。”</p><p>——木心</p><p>（四季三餐，如何是好）</p><p>8</p><p>不谦而狂的人，狂不到哪里去；不狂而谦的人，真不知其在谦什么。</p><p>——木心 《琼美卡随想录》</p><p>（收下我的膝盖……）</p><p>9</p><p>雨后总像有谁离去了。</p><p>——木心 《素履之往》</p><p>（雨后寥落，若有亡失）</p><p>10</p><p>常以为人是一种容器，盛着快乐，盛着悲哀。但人不是容器，人是导管，快乐流过，悲哀流过，导管只是导管。各种快乐悲哀流过流过，一直到死，导管才空了。疯子就是导管的淤塞和破裂。</p><p>——木心 《同车人的啜泣》</p><p>（过的就过了，没过的，就塌陷了……）</p><p>11</p><p>悲伤有很多种，能加以抑制的悲伤，未必称得上悲伤。</p><p>——木心 《即兴判断》</p><p>（正如，能加以抑制的真情，未必称得上真情）</p><p>12</p><p>规律背后，有命运在冷笑。</p><p>——木心</p><p>（除了敬畏，别无其他）</p><p>13</p><p>一流的情人永远不必殉陨，永远不会失恋，因为“我爱你，与你何涉。”</p><p>——木心</p><p>（爱你，我的爱情便成了）</p><p>14</p><p>没有比粥更温柔的了。念予毕生流离红尘，就找不到一个似粥温柔的人。</p><p>——木心 《少年朝食》</p><p>（未有粥一般的人，甚或，连粥一般的话都无）</p><p>15</p><p>爱情，亦三种境界耳。少年出乎好奇，青年在于审美，中年归向求知。老之将至，义无反顾。</p><p>——木心 《即兴判断》</p><p>（到老来，却是清醒深情）</p><p>16</p><p>负心，不奇。奇的是负心之前的一片真心</p><p>——木心 《云雀叫了一整天》</p><p>（因有负心为根，方显真心丑恶）</p><p>17</p><p>一个人，随便走几步，性格毕露。</p><p>——木心 《云雀叫了一整天》</p><p>（他的举止里，全是言语）</p><p>18</p><p>无论蓬户荆扉，都将因你的倚闾而成为我的凯旋门。</p><p>——木心</p><p>（世事本无意义，因你面目全非）</p><p>19</p><p>一场梦，不怨也不恨，上了想象力的当。</p><p>——木心 《温莎墓园日记》</p><p>（爱憎，莫扰无底色的梦）</p><p>20</p><p>没有自我的人的自我感觉都特别良好。</p><p>——木心 《素履之往》</p><p>（天大地大，自大最大）</p><p>21</p><p>有人一看书就卖弄，多看几遍再卖弄吧……多看几遍就不卖弄了。</p><p>——木心</p><p>（越多知，越懂无知）</p><p>23</p><p>文字的简练来自内心的真诚。我十二万分的爱你，就不如我爱你。</p><p>——木心</p><p>（爱已经太长，话就短些吧）</p><p>24</p><p>爱一个人，没有机会表白，后来决计绝念。再后来，消息时有所闻，偶尔也见面。幸亏那时未曾说出口，幸亏究竟不能算真的爱上。又爱了另一个人，表白的机会不少，想想，懒下来，懒成朋友，至今还朋友着。光阴荏苒，在电话里有说有笑，心中兀自庆幸，还好……否则苦了。</p><p>——木心 《素履之往》</p><p>（错过得并无遗憾，错过得只剩美感）</p><p>25</p><p>当愚人来找你商量事体，你别费精神——他早就定了主意的。</p><p>——木心 《素履之往》</p><p>（无谓的苦口婆心，不如沉默是金）</p><p>26</p><p>给他们面子是我自己要面子。</p><p>——木心 《云雀叫了一整天》</p><p>27</p><p>眼看一个个有志青年，熟门熟路地堕落了，许多“个人”加起来，便是“时代”。</p><p>——木心 《素履之往》</p><p>（低头自问，是否在时代的驼背之上，加了一根小小的稻草）</p><p>28</p><p>晴秋上午，随便走走，不一定要快乐。</p><p>——木心 《素履之往》</p><p>（字词自己腾跃，并不非得意义）</p><p>29</p><p>轻浮，随遇而爱，谓之滥情。多方向，无主次地泛恋，谓之滥情。言过其实，炫耀伎俩，谓之滥情。没条件的痴心忠于某一人，亦谓之滥情。</p><p>——木心 《素履之往》</p><p>（没有尺度，都是坍塌）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 文字 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
            <tag> 木心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello Hexo</title>
      <link href="/2019/09/11/hello-world/"/>
      <url>/2019/09/11/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Hello-hexo！！"><a href="#Hello-hexo！！" class="headerlink" title="Hello hexo！！"></a>Hello hexo！！</h3><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Hello Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hello </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
