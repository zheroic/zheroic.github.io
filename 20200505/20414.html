<!DOCTYPE HTML>
<html lang="zh-CN">
    <!-- shw2018 洪卫  modify 2019.08.15-->



<head>
    <meta charset="utf-8">
    <meta name="keywords" content="知识整理, 东北大学 软件工程 大数据 zheroic">
    <meta name="baidu-site-verification" content="fmlEuI34ir" />
    <meta name="google-site-verification" content="KeoTn_OFy4ndJwXNmm2gMeQfPhd7alqE9vQDwI32KCY" />
    <meta name="description" content="Java基础抽象类可以不包含抽象方法, 包含抽象方法的类一定是抽象类。十进制转二进制int n=5;
String s = Integer.toBinaryString(n);
String 、 StringBuilder 、 String">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>知识整理 | zheroic&#39;s blog</title>
    <link rel="icon" type="image/png" href="https://s1.ax1x.com/2020/04/26/JgP8Zd.png">

    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/zheroic/zheroic.github.io/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/zheroic/zheroic.github.io/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/zheroic/zheroic.github.io/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/zheroic/zheroic.github.io/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/zheroic/zheroic.github.io/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    
    <style type="text/css">
        
            
            code[class*="language-"],
            pre[class*="language-"] {
                white-space: pre !important;
            }

        
    </style>

    <script src="https://cdn.jsdelivr.net/gh/zheroic/zheroic.github.io/libs/jquery/jquery-2.2.0.min.js"></script>
    <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
    
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?46e79e71af0709a5b9106bf20cecc493";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

    
    
        <script>
            (function(){
                var bp = document.createElement('script');
                var curProtocol = window.location.protocol.split(':')[0];
                if (curProtocol === 'https') {
                    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
                }
                else {
                    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
                }
                var s = document.getElementsByTagName("script")[0];
                s.parentNode.insertBefore(bp, s);
            })();
        </script>
    

<meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

    <body>

        <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="https://cdn.jsdelivr.net/gh/zheroic/zheroic.github.io/images/loading.gif" data-original="https://s1.ax1x.com/2020/04/26/JgP8Zd.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">zheroic's blog</span>
                </a>
            </div>
            


<!-- <a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/List" class="waves-effect waves-light">
            
            <i class="fa fa-heartbeat"></i>
            
            <span>清单</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于我</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/contact" class="waves-effect waves-light">
            
            <i class="fa fa-envelope"></i>
            
            <span>留言板</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <i class="fa fa-address-book"></i>
            
            <span>友情链接</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul> -->

<!-- 支持二级菜单特性 洪卫 shw2018 modify 2019.09.17  -->
<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right nav-menu">
    
      <li class="hide-on-med-and-down nav-item" >

        
            <a href="/" class="waves-effect waves-light">
              
                <i class="fa fa-home"></i>
              
              <span>首页</span>
            </a>

            
      </li>
    
      <li class="hide-on-med-and-down nav-item" >

        
              <a href="/archives" class="waves-effect waves-light">
                
                  <i class="fa fa-archive"></i>
                
                <span>归档</span>
                <i class="fa fa-chevron-down" aria-hidden="true"></i>
              </a>

            <ul class="sub-nav menus_item_child ">
              
                <li> 
                  <a href="/archives" >
                    
                      <i class="fa fa-archive" style="margin-top: -20px;"></i>
                    
                    <span>时间轴</span>
                  </a>
                </li>
              
                <li> 
                  <a href="/tags" >
                    
                      <i class="fa fa-tags" style="margin-top: -20px;"></i>
                    
                    <span>标签</span>
                  </a>
                </li>
              
                <li> 
                  <a href="/categories" >
                    
                      <i class="fa fa-bookmark" style="margin-top: -20px;"></i>
                    
                    <span>分类</span>
                  </a>
                </li>
               
            </ul>
          
      </li>
    
      <li class="hide-on-med-and-down nav-item" >

        
              <a href="/List" class="waves-effect waves-light">
                
                  <i class="fa fa-heartbeat"></i>
                
                <span>清单</span>
                <i class="fa fa-chevron-down" aria-hidden="true"></i>
              </a>

            <ul class="sub-nav menus_item_child ">
              
                <li> 
                  <a href="/List/music" >
                    
                      <i class="fa fa-music" style="margin-top: -20px;"></i>
                    
                    <span>音乐</span>
                  </a>
                </li>
              
                <li> 
                  <a href="/List/videos" >
                    
                      <i class="fa fa-film" style="margin-top: -20px;"></i>
                    
                    <span>视频</span>
                  </a>
                </li>
              
                <li> 
                  <a href="/List/mygalleries" >
                    
                      <i class="fa fa-photo" style="margin-top: -20px;"></i>
                    
                    <span>相册</span>
                  </a>
                </li>
               
            </ul>
          
      </li>
    
      <li class="hide-on-med-and-down nav-item" >

        
            <a href="/about" class="waves-effect waves-light">
              
                <i class="fa fa-user-circle-o"></i>
              
              <span>关于我</span>
            </a>

            
      </li>
    
      <li class="hide-on-med-and-down nav-item" >

        
            <a href="/contact" class="waves-effect waves-light">
              
                <i class="fa fa-envelope"></i>
              
              <span>留言板</span>
            </a>

            
      </li>
    
      <li class="hide-on-med-and-down nav-item" >

        
            <a href="/friends" class="waves-effect waves-light">
              
                <i class="fa fa-address-book"></i>
              
              <span>友情链接</span>
            </a>

            
      </li>
    

    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>

</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="https://cdn.jsdelivr.net/gh/zheroic/zheroic.github.io/images/loading.gif" data-original="https://s1.ax1x.com/2020/04/26/JgP8Zd.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">zheroic's blog</div>
        <div class="logo-desc">
            
            东北大学 | 软件工程 | 大数据
            
        </div>
    </div>

    
<!--
    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/List" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-heartbeat"></i>
                
                清单
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                关于我
            </a>
        </li>
        
        <li>
            <a href="/contact" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-envelope"></i>
                
                留言板
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-address-book"></i>
                
                友情链接
            </a>
        </li>
        
        
    </ul>
-->
   
   
<!-- 支持二级菜单特性 洪卫 shw2018 modify 2019.09.17  -->
<ul class="menu-list mobile-menu-list">
    
        <li class="m-nav-item">
                
                    <a href="/" class="waves-effect waves-light">
                        
                        <i class="fa fa-fw fa-home"></i>
                        
                        首页
                    </a>
              
            </li>
        
        <li class="m-nav-item">
                
                    <a href="javascript:;">
                            
                            <i class="fa fa-fw fa-archive"></i>
                            
                            归档
                            <span class="m-icon"><i class="fa fa-chevron-right"></i></span>
                    </a>
                <ul>
                  
                    <li> 
                      <a href="/archives" >
                           
                            <i class="fa fa-archive" style="left: 18px; position: absolute;"></i>
                       
                       <span>时间轴</span>
                      </a>
                    </li>
                  
                    <li> 
                      <a href="/tags" >
                           
                            <i class="fa fa-tags" style="left: 18px; position: absolute;"></i>
                       
                       <span>标签</span>
                      </a>
                    </li>
                  
                    <li> 
                      <a href="/categories" >
                           
                            <i class="fa fa-bookmark" style="left: 18px; position: absolute;"></i>
                       
                       <span>分类</span>
                      </a>
                    </li>
                   
                </ul>
              
            </li>
        
        <li class="m-nav-item">
                
                    <a href="javascript:;">
                            
                            <i class="fa fa-fw fa-heartbeat"></i>
                            
                            清单
                            <span class="m-icon"><i class="fa fa-chevron-right"></i></span>
                    </a>
                <ul>
                  
                    <li> 
                      <a href="/List/music" >
                           
                            <i class="fa fa-music" style="left: 18px; position: absolute;"></i>
                       
                       <span>音乐</span>
                      </a>
                    </li>
                  
                    <li> 
                      <a href="/List/videos" >
                           
                            <i class="fa fa-film" style="left: 18px; position: absolute;"></i>
                       
                       <span>视频</span>
                      </a>
                    </li>
                  
                    <li> 
                      <a href="/List/mygalleries" >
                           
                            <i class="fa fa-photo" style="left: 18px; position: absolute;"></i>
                       
                       <span>相册</span>
                      </a>
                    </li>
                   
                </ul>
              
            </li>
        
        <li class="m-nav-item">
                
                    <a href="/about" class="waves-effect waves-light">
                        
                        <i class="fa fa-fw fa-user-circle-o"></i>
                        
                        关于我
                    </a>
              
            </li>
        
        <li class="m-nav-item">
                
                    <a href="/contact" class="waves-effect waves-light">
                        
                        <i class="fa fa-fw fa-envelope"></i>
                        
                        留言板
                    </a>
              
            </li>
        
        <li class="m-nav-item">
                
                    <a href="/friends" class="waves-effect waves-light">
                        
                        <i class="fa fa-fw fa-address-book"></i>
                        
                        友情链接
                    </a>
              
            </li>
        

        
    </ul>

</div>

        </div>

        
    </nav>

</header>

        
<script src="https://cdn.jsdelivr.net/gh/zheroic/zheroic.github.io/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('https://s1.ax1x.com/2020/04/26/JgTaZD.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        知识整理
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zheroic/zheroic.github.io/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- shw2018 洪卫  modify 2019.08.15-->
<!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/java/" target="_blank">
                                <span class="chip bg-color">java</span>
                            </a>
                        
                            <a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" target="_blank">
                                <span class="chip bg-color">大数据</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/java/" class="post-category" target="_blank">
                                java
                            </a>
                        
                            <a href="/categories/java/%E5%A4%A7%E6%95%B0%E6%8D%AE/" class="post-category" target="_blank">
                                大数据
                            </a>
                        
                    </div>
                    
                </div>
            </div>
            
            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-05-05
                </div>

                <div class="post-author info-break-policy">
                    <i class="fa fa-user-o fa-fw"></i>作者:&nbsp;&nbsp;
                    
                        zheroic
                    
                </div>

                
                    
                    <div class="info-break-policy">
                        <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                        22.9k
                    </div>
                    

                    
                    <div class="info-break-policy">
                        <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                        83 分
                    </div>
                    
                
                
                
                        <span id="busuanzi_container_site_pv" style='display:none'></span>
                        <i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv" ></span>
    
                

            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="抽象类可以不包含抽象方法-包含抽象方法的类一定是抽象类。"><a href="#抽象类可以不包含抽象方法-包含抽象方法的类一定是抽象类。" class="headerlink" title="抽象类可以不包含抽象方法, 包含抽象方法的类一定是抽象类。"></a>抽象类可以不包含抽象方法, 包含抽象方法的类一定是抽象类。</h3><h3 id="十进制转二进制"><a href="#十进制转二进制" class="headerlink" title="十进制转二进制"></a>十进制转二进制</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">int</span> n<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>
String s <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">toBinaryString</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="String-、-StringBuilder-、-StringBuffer-的区别？"><a href="#String-、-StringBuilder-、-StringBuffer-的区别？" class="headerlink" title="String 、 StringBuilder 、 StringBuffer 的区别？"></a>String 、 StringBuilder 、 StringBuffer 的区别？</h3><p>Java 平台提供了两种类型的字符串： String 和 StringBuffer/StringBuilder，它们都可以储存和操作字符串， 区别<br>如下。<br>1） String 是只读字符串，也就意味着 String 引用的字符串内容是不能被改变的。 初学者可能会有这样的误解：</p>
<pre class="line-numbers language-java"><code class="language-java">String str <span class="token operator">=</span> “abc”；
str <span class="token operator">=</span> “bcd”<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如上，字符串 str 明明是可以改变的呀！其实不然， str 仅仅是一个引用对象，它指向一个字符串对象“abc”。第<br>二行代码的含义是让 str 重新指向了一个新的字符串“bcd”对象，而“abc”对象并没有任何改变，只不过该对象已<br>经成为一个不可及对象罢了。<br>2） StringBuffer/StringBuilder 表示的字符串对象可以直接进行修改。<br>3） StringBuilder 是 Java5 中引入的，它和 StringBuffer 的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方法都没有被 synchronized 修饰，因此它的效率理论上也比 StringBuffer 要高。  </p>
<p>StringBuffer 和 StringBuilder 的功能基本一样，只是<strong>StringBuffer 是线程安全的，而 StringBuilder 不是线程安全的</strong>。因此， StringBuilder 的效率会更高。  </p>
<h3 id="Vector-ArrayList-LinkedList的区别"><a href="#Vector-ArrayList-LinkedList的区别" class="headerlink" title="Vector,ArrayList,LinkedList的区别"></a>Vector,ArrayList,LinkedList的区别</h3><p>1.<strong>ArrayList</strong>是最常用的List实现类，内部是通过<strong>数组</strong>实现的，它允许对元素进行<strong>快速随机访问</strong>。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要讲已经有数组的数据复制到新的存储空间中。当从ArrayList的中间位置插入或者删除元素时，<strong>需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。</strong><br>2.<strong>Vector</strong>与ArrayList一样，也是通过数组实现的，<strong>不同的是它支持线程的同步</strong>，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢。<br>3.LinkedList是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了List接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈主要包含两个操作，主要是入栈和出栈（插入和读取并删除）操作。<br>栈既可以用数组实现，也可以用链表实现，用数组实现的栈称为顺序栈，用链表实现的栈称为链式栈。</p>
<h4 id="利用栈实现浏览器的前进后退功能"><a href="#利用栈实现浏览器的前进后退功能" class="headerlink" title="利用栈实现浏览器的前进后退功能"></a>利用栈实现浏览器的前进后退功能</h4><p>使用两个栈 X 和 Y，把首次浏览的页面依次压入栈 X，当点击后退按钮时，再依次从栈 X 中出栈，并将出栈的数据依次放入栈 Y。当点击前进按钮时，依次从栈 Y 中取出数据，放入栈 X 中。当栈 X 中没有数据时，那就说明没有页面可以继续后退浏览了。当栈 Y 中没有数据，那就说明没有页面可以点击前进按钮浏览了。</p>
<h3 id="int和Integer的区别"><a href="#int和Integer的区别" class="headerlink" title="int和Integer的区别"></a>int和Integer的区别</h3><p>1.int是基本数据类型，Integer是int的包装类就是将int类型包装成Object对象；<br>2.Integer变量必须实例化后才能使用；int变量不需要；<br>3.Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值 ；<br>4.Integer的默认值是null；int的默认值是0。</p>
<p>深入：</p>
<ul>
<li><strong>两个通过new生成的Integer变量永远是不相等的。因为new生成的是两个对象，其内存地址不同。</strong></li>
<li><strong>Integer与new Integer不会相等</strong>。因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同。 </li>
<li><strong>两个都是非new出来的Integer，如果数在-128到127之间，则是true,否则为false。</strong><ul>
<li>java在编译Integer i = 127的时候,被翻译成 Integer i = Integer.valueOf(127);  java API中对Integer类型的valueOf的定义如下，对于-128到127之间的数，会进行缓存，Integer i = 127时，会将127这个Integer对象进行缓存，下次再写Integer j = 127时，就会直接从缓存中取，就不会new了。</li>
</ul>
</li>
<li><strong>Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true。</strong>（因为包装类Integer和基本数据类型int比较时，java会自动拆箱为int，然后进行比较，实际上就变为两个int变量的比较）</li>
</ul>
<h3 id="为什么有了int还要Integer"><a href="#为什么有了int还要Integer" class="headerlink" title="为什么有了int还要Integer"></a>为什么有了int还要Integer</h3><ul>
<li>对象封装有很多好处，可以把属性也就是数据跟处理这些数据的方法结合在一起，比如Integer就有parseInt()等方法来专门处理int型相关的数据。　　</li>
<li>另一个非常重要的原因就是在Java中绝大部分方法或类都是用来处理类类型对象的，如ArrayList集合类就只能以类作为他的存储对象，而这时如果想把一个int型的数据存入list是不可能的，必须把它包装成类，也就是Integer才能被List所接受。所以Integer的存在是很必要的</li>
</ul>
<h3 id="char类型不使用内置函数转换成int（char-‘0’"><a href="#char类型不使用内置函数转换成int（char-‘0’" class="headerlink" title="char类型不使用内置函数转换成int（char-‘0’)"></a>char类型不使用内置函数转换成int（char-‘0’)</h3><pre><code>char a = '9';
int res = a-'0';
必须要进行这一操作才能转化res才会等于9</code></pre><h2 id="hashMap底层实现原理及面试问题"><a href="#hashMap底层实现原理及面试问题" class="headerlink" title="hashMap底层实现原理及面试问题"></a>hashMap底层实现原理及面试问题</h2><ol>
<li>hashmap的工作原理：</li>
</ol>
<p>HashMap的数据结构为 数组+链表（jdk7)/数组+链表+红黑树（jdk8)</p>
<p>为什么采用这种结构来存储元素呢？数组的特点：查询效率高，插入，删除效率低。链表的特点：查询效率低，插入删除效率高。在HashMap底层使用数组加（链表或红黑树）的结构完美的解决了数组和链表的问题，使得查询和插入，删除的效率都很高。</p>
<p><strong>HashMap基于hashing原理，通过put()、get()存储和获取对象。当我们将键值传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，然后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象。</strong></p>
<p>当两个不同的键对象的hashcode相同时会发生什么？ 它们会储存在同一个bucket位置的链表中。键对象的equals()方法用来找到键值对。</p>
<h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><p>1.最好情况最坏情况平均情况：</p>
<p>快速排序的<strong>时间性能</strong>取决于快速排序递归的深度，可以用递归树来描述递归算法的执行情况。如图9‐9‐7所示，它是{50,10,90,30, 70,40,80,60,20}在快速排序过程中的递归过程。由于我们的第一个关键字是50，正好是待排序的序列的中间值，因此递归树是平衡的，此时性能也比较好。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zheroic/zheroic.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/zheroic/BlogMedias/images/20200505172050.jpg" alt="cafd6b26763a392ad0fbef50aa12d620.jpeg"></p>
<p><strong>在最优情况下</strong>，Partition每次都划分得很均匀，如果排序n个关键字，其递归树的深度就为[log2n]+1（[x]表示不大于x的最大整数），即仅需递归log2n次，需要时间为T（n）的话，第一次Partiation应该是需要对整个数组扫描一遍，做n次比较。然后，获得的枢轴将数组一分为二，那么各自还需要T（n/2）的时间（注意是最好情况，所以平分两半）。于是不断地划分下去，我们就有了下面的不等式推断。<br>T（n）≤2T（n/2）&nbsp;+n，T（1）=0 &nbsp;<br>T（n）≤2（2T（n/4）+n/2）&nbsp;+n=4T（n/4）+2n &nbsp;<br>T（n）≤4（2T（n/8）+n/4）&nbsp;+2n=8T（n/8）+3n &nbsp;<br>…… &nbsp;<br>T（n）≤nT（1）+（log2n）×n=&nbsp;O(nlogn)&nbsp;<br>也就是说，在最优的情况下，快速排序算法的时间复杂度为O(nlogn)。<br><strong>在最坏的情况下</strong>，待排序的序列为正序或者逆序，每次划分只得到一个比上一次划分少一个记录的子序列，注意另一个为空。如果递归树画出来，它就是一棵斜树。此时需要执行n‐1次递归调用，且第i次划分需要经过n‐i次关键字的比较才能找到第i个记录，也就是枢轴的位置，因此比较次数为<img src="https://cdn.jsdelivr.net/gh/zheroic/zheroic.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/zheroic/BlogMedias/images/20200505172641.png" alt="019df2dc2b2d692086a68b3e7bf8fbac.png"></p>
<p>&nbsp;，最终其时间复杂度为O(n2)。<br><strong>平均情况</strong>，，设枢轴的关键字应该在第k的位置（1≤k≤n），那么：<img src="https://cdn.jsdelivr.net/gh/zheroic/zheroic.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/zheroic/BlogMedias/images/20200505172244.jpg" alt="ee1956b6600ee3e40e2b0a8624fdbcba.jpeg"><br>&nbsp;由数学归纳法可证明，其数量级为O(nlogn)。</p>
<p>就<strong>空间复杂度</strong>来说，主要是递归造成的栈空间的使用，<br>最好情况，递归树的深度为log2n，其空间复杂度也就为O(logn)，<br>最坏情况，需要进行n‐1递归调用，其空间复杂度为O(n)，<br>平均情况，空间复杂度也为O(logn)。<br>可惜的是，由于关键字的比较和交换是跳跃进行的，因此，快速排序是一种不稳定的排序方法。</p>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="1-JVM运行时区域："><a href="#1-JVM运行时区域：" class="headerlink" title="1.JVM运行时区域："></a>1.JVM运行时区域：</h3><p>Java虚拟机的运行时区域构成图如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zheroic/zheroic.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/zheroic/BlogMedias/images/20200505172828.png" alt=""></p>
<p>线程共享区域：</p>
<p>Java堆：<br>（1）Java堆是java虚拟机所管理的内存中最大的一块；<br>（2）被所有线程共享区域，在虚拟机启动时创建，唯一目的存放对象实例，<strong>存储的全部是对象，每个对象都包含一个与之对应的class的信息。(class的目的是得到操作指令)，jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身；</strong><br>（3）堆区是gc的主要区域，通常情况下分为两个区块年轻代和年老代。更细一点年轻代又分为Eden区最要放新创建对象，From survivor 和 To survivor 保存gc后幸存下的对象，默认情况下各自占比 8:1:1。 进一步划分的目的是为了更还的内存回收或者更快的内存分配；<br>（4）会有异常OutOfMemoneyError；</p>
<p>方法区：<br><strong>又叫静态区，跟堆一样，被所有的线程共享。方法区包含所有的class和static变量。方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量。</strong><br>（1）被所有线程共享区域，用于存放已被虚拟机加载的类信息，常量，静态变量等数据。被Java虚拟机描述为堆的一个逻辑部分。习惯是也叫它永久代（仅仅是因为HotSpot虚拟机选择把GC分代收集扩展至方法区）；<br>（2）垃圾回收很少光顾这个区域，不过也是需要回收的，主要针对常量池回收，类型卸载。<br>（3）会有异常OutOfMemoneyError；</p>
<p>线程私有区域：</p>
<p>程序计数器：<br>（1）当前线程所执行的字节码指令的行号指示器，如分支、跳转、循环、异常处理、线程恢复都依赖程序计数器实现；<br>（2）Java多线程是通过线程轮流切换并分配CPU时间片来执行的，为了线程切换后能恢复到正确的位置，所以每个线程都有一个单独的程序计数器，所以程序计数器是私有的；<br>（3）Jvm没有规定OutOfMemory的区块；</p>
<p>栈：<br><strong>每个线程包含一个栈区，栈中只保存基础数据类型的对象和自定义对象的引用(不是对象)，对象都存放在堆区中；每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。；栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。</strong><br>1.Java虚拟机栈：<br>（1）为执行Java方法服务‘<br>（2）当线程创建的时候，为线程分配一块内存区域，在线程执行的过程中，每个方法的执行都会创建一个栈帧，用于存放局部变量表、操作栈、动态链接，方法出口等。每个方法从被调用，直到被执行完。对应着一个栈帧在虚拟机中从入栈到出栈的过程；<br>（3）会有两种异常StackOverFlowError和 OutOfMemoneyError。当线程请求栈深度大于虚拟机所允许的深度就会抛出StackOverFlowError错误；虚拟机栈动态扩展，当扩展无法申请到足够的内存空间时候，抛出OutOfMemoneyError；<br>（4）它是线程私有的，生命周期与线程相同；<br>2.本地方法栈：<br>（1）与java虚拟机栈所发挥的作用非常相似，它们之间的区别在于java虚拟机栈执行java方法服务的，本地方法栈是执行本地方法服务的</p>
<h3 id="程序运行顺序"><a href="#程序运行顺序" class="headerlink" title="程序运行顺序"></a>程序运行顺序</h3><p><img src="https://cdn.jsdelivr.net/gh/zheroic/zheroic.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/zheroic/BlogMedias/images/20200505173024.png" alt="2a57dc92f06be337261541033f712803.png"></p>
<h3 id="为什么main方法是静态的（static）"><a href="#为什么main方法是静态的（static）" class="headerlink" title="为什么main方法是静态的（static）"></a>为什么main方法是静态的（static）</h3><ul>
<li>正因为main方法是静态的，JVM调用这个方法就不需要创建任何包含这个main方法的实例。</li>
<li>因为C和C++同样有类似的main方法作为程序执行的入口。</li>
<li>如果main方法不声明为静态的，JVM就必须创建main类的实例，因为构造器可以被重载，JVM就没法确定调用哪个main方法。</li>
<li>静态方法和静态数据加载到内存就可以直接调用而不需要像实例方法一样创建实例后才能调用，如果main方法是静态的，那么它就会被加载到JVM上下文中成为可执行的方法。<h3 id="为什么main方法是公有的（public）"><a href="#为什么main方法是公有的（public）" class="headerlink" title="为什么main方法是公有的（public）"></a>为什么main方法是公有的（public）</h3> Java指定了一些可访问的修饰符如：private、protected、public，任何方法或变量都可以声明为public，Java可以从该类之外的地方访问。因为main方法是公共的，JVM就可以轻松的访问执行它。</li>
</ul>
<h3 id="为什么main方法没有返回值（Void）"><a href="#为什么main方法没有返回值（Void）" class="headerlink" title="为什么main方法没有返回值（Void）"></a>为什么main方法没有返回值（Void）</h3><p>   因为main返回任何值对程序都没任何意义，所以设计成void，意味着main不会有任何值返回</p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="在java中有哪些锁？该如何进行分类呢？"><a href="#在java中有哪些锁？该如何进行分类呢？" class="headerlink" title="在java中有哪些锁？该如何进行分类呢？"></a>在java中有哪些锁？该如何进行分类呢？</h3><p>1.共享锁/排他锁<br>  共享锁和排他锁是从同一时刻是否允许多个线程持有该锁的角度来划分。<br>  共享锁允许同一时刻多个线程进入持有锁，访问临界区资源。而排他锁就是通常意义上的锁，同一时刻只允许一个线程访问临界资源。对于共享锁，主要是指对数据库读操作中的读锁，在读写资源的时候如果没有线程持有写锁和请求写锁，则此时允许多个线程持有读锁。<br>2.乐观锁/悲观锁<br>  主要用于数据库数据的操作中，而对于线程锁中较为少见。<br>  悲观锁和乐观锁是一种加锁思想。<br>  对于乐观锁，在进行数据读取的时候不会加锁，而在进行写入操作的时候会判断一下数据是否被其它线程修改过，如果修改则更新数据，如果没有则继续进行数据写入操作。乐观锁不是系统中自带的锁，而是一种数据读取写入思想。应用场景例如：在向数据库中插入数据的时候，先从数据库中读取记录修改版本标识字段，如果该字段没有发生变化（没有其他线程对数据进行写操作）则执行写入操作，如果发生变化则重新计算数据。<br>  对于悲观锁，无论是进行读操作还是进行写操作都会进行加锁操作。对于悲观锁，如果并发量较大则比较耗费资源，当然保证了数据的安全性。<br>3.可复入锁/不可复入<br>  这两个概念是从同一个线程在已经持有锁的前提下能否再次持有锁的角度来区分的。<br>  对于可重入锁，如果该线程已经获取到锁且未释放的情况下允许再次获取该锁访问临界区资源。此种情况主要是用在递归调用的情况下和不同的临界区使用相同的锁的情况下。<br>  对于不可重入锁，则不允许同一线程在持有锁的情况下再次获取该锁并访问临界区资源。对于不可重入锁，使用的时候需要小心以免造成死锁。<br>4.公平锁/非公平锁<br>  这两个概念主要使用线程获取锁的顺序角度来区分的。<br>  对于公平锁，所有等待的线程按照按照请求锁的先后循序分别依次获取锁。<br>  对于非公平锁，等待线程的线程获取锁的顺序和请求的先后不是对应关系。有可能是随机的获取锁，也有可能按照其他策略获取锁，总之不是按照FIFO的顺序获取锁。<br>  在使用ReentrantLock的时候可以通过构造方法主动选择是实现公平锁还是非公平锁。<br>5.自旋锁/非自旋锁<br>  这两种概念是从线程等待的处理机制来区分的。<br>  自旋锁在进行锁请求等待的时候不进行wait挂起，不释放CPU资源，执行while空循环。直至获取锁访问临界区资源。适用于等待锁时间较短的情景，如果等待时间较长，则会耗费大量的CPU资源。而如果等待时间较短则可以节约大量的线程切换资源。<br>  非自旋锁在进行锁等待的时候会释放CPU资源，可以通多sleep wait 或者CPU中断切换上下文，切换该线程。在线程等待时间较长的情况下可以选择此种实现机制。<br>  除此之外还有一种介于两者之间的锁机制——自适应自旋锁。当线程进行等待的时候先进性自旋等待，在自旋一定时间(次数)之后如果依旧没有持有锁则挂起等待。在jvm中synchronized锁已经使用该机制进行处理锁等待的情况。<br>6.也可以通过信号量实现锁</p>
<h3 id="什么是CAS？"><a href="#什么是CAS？" class="headerlink" title="什么是CAS？"></a>什么是CAS？</h3><p>  CAS是compare and swap的缩写，即我们所说的比较交换。cas是一种基于锁的操作，而且是乐观锁。在java中锁分为乐观锁和悲观锁。悲观锁是将资源锁住，等一个之前获得锁的线程释放锁之后，下一个线程才可以访问。而乐观锁采取了一种宽泛的态度，通过某种方式不加锁来处理资源，比如通过给记录加version来获取数据，性能较悲观锁有很大的提高。<br>　　 CAS操作包含三个操作数 ——内存位置（V）、预期原值（A）和新值(B)。如果内存地址里面的值和A的值是一样的，那么就将内存里面的值更新成B。CAS是通过无限循环来获取数据的，若果在第一轮循环中，a线程获取地址里面的值被b线程修改了，那么a线程需要自旋，到下次循环才有可能机会执行。java.util.concurrent.atomic 包下的类大多是使用CAS操作来实现的( AtomicInteger,AtomicBoolean,AtomicLong)。</p>
<h3 id="CAS的问题？"><a href="#CAS的问题？" class="headerlink" title="CAS的问题？"></a>CAS的问题？</h3><p>1）CAS容易造成ABA问题。一个线程a将数值改成了b，接着又改成了a，此时CAS认为是没有变化，其实是已经变化过了，而这个问题的解决方案可以使用版本号标识，每操作一次version加1。在java5中，已经提供了AtomicStampedReference来解决问题。<br>2） 不能保证代码块的原子性，CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用synchronized了。<br>3）CAS造成CPU利用率增加。之前说过了CAS里面是一个循环判断的过程，如果线程一直没有获取到状态，cpu资源会一直被占用。</p>
<h3 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h3><p>在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分3种类型，分别为编译器优化重排序、指令级并行重排序、内存系统重排序。</p>
<p>1）编译器优化的重排序。<br>编译器在不改变单线程程序语义的前提下，可以重新安排语句 的执行顺序。</p>
<p>2）指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p>
<p>3）内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</p>
<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><h3 id="数据可靠性保证"><a href="#数据可靠性保证" class="headerlink" title="数据可靠性保证"></a>数据可靠性保证</h3><p>当Producer向Leader发送数据时，可以通过acks参数设置数据可靠性的级别<br>0: 不论写入是否成功，server不需要给Producer发送Response，如果发生异常，server会终止连接，触发Producer更新meta数据；<br>1: Leader写入成功后即发送Response，此种情况如果Leader fail，会丢失数据，<strong>默认设置</strong><br>-1: 等待所有ISR接收到消息后再给Producer发送Response，这是最强保证<br>（ISR全称是“In-Sync Replicas”，也就是保持同步的副本，他的含义就是，跟Leader始终保持同步的Follower有哪些）<br><em>仅设置acks=-1也不能保证数据不丢失，当Isr列表中只有Leader时，同样有可能造成数据丢失。要保证数据不丢除了设置acks=-1, 还要保证ISR的大小大于等于2，具体参数设置：</em><br>request.required.acks：设置为-1 等待所有ISR列表中的Replica接收到消息后采算写成功；min.insync.replicas: 设置为大于等于2，保证ISR中至少有两个Replica</p>
<p>Producer要在吞吐率和数据可靠性之间做一个权衡</p>
<h3 id="数据一致性保证"><a href="#数据一致性保证" class="headerlink" title="数据一致性保证"></a>数据一致性保证</h3><p>一致性定义：若某条消息对client可见，那么即使Leader挂了，在新Leader上数据依然可以被读到<br>  HW-HighWaterMark: client可以从Leader读到的最大msg offset，即对外可见的最大offset， HW=max(replica.offset)<br>  对于Leader新收到的msg，client不能立刻消费，Leader会等待该消息被所有ISR中的replica同步后，更新HW，此时该消息才能被client消费，这样就保证了如果Leader fail，该消息仍然可以从新选举的Leader中获取。<br>  对于来自内部Broker的读取请求，没有HW的限制。同时，Follower也会维护一份自己的HW，Folloer.HW = min(Leader.HW, Follower.offset)</p>
<h3 id="Kafka为什么吞吐量达，速度快"><a href="#Kafka为什么吞吐量达，速度快" class="headerlink" title="Kafka为什么吞吐量达，速度快"></a>Kafka为什么吞吐量达，速度快</h3><p>Kafka虽然是基于磁盘做的数据存储，但却具有高性能、高吞吐、低延时的特点，其吞吐量动辄几万、几十上百万。</p>
<h4 id="1-顺序读写："><a href="#1-顺序读写：" class="headerlink" title="1.顺序读写："></a>1.顺序读写：</h4><p>Kafka就是使用了磁盘顺序读写来提升的性能。Kafka的message是不断追加到本地磁盘文件末尾的，而不是随机的写入，这使得Kafka写入吞吐量得到了显著提升 。</p>
<h4 id="2-Page-Cache："><a href="#2-Page-Cache：" class="headerlink" title="2.Page Cache："></a>2.Page Cache：</h4><p>通过操作系统的Page Cache，Kafka的读写操作基本上是基于内存的，读写速度得到了极大的提升。<br> 为了优化读写性能，Kafka利用了操作系统本身的Page Cache，就是利用操作系统自身的内存而不是JVM空间内存。这样做的好处有：<br>  1）避免Object消耗：如果是使用 Java 堆，Java对象的内存消耗比较大，通常是所存储数据的两倍甚至更多。<br>  2）避免GC问题：随着JVM中数据不断增多，垃圾回收将会变得复杂与缓慢，使用系统缓存就不会存在GC问题</p>
<h4 id="3-零拷贝："><a href="#3-零拷贝：" class="headerlink" title="3.零拷贝："></a>3.零拷贝：</h4><p>linux操作系统 “零拷贝” 机制使用了sendfile方法， 允许操作系统将数据从Page Cache 直接发送到网络，只需要最后一步的copy操作将数据复制到 NIC 缓冲区， 这样避免重新复制数据 。</p>
<p>通过这种 “零拷贝” 的机制，Page Cache 结合 sendfile 方法，Kafka消费端的性能也大幅提升。这也是为什么有时候消费端在不断消费数据时，我们并没有看到磁盘io比较高，此刻正是操作系统缓存在提供数据。</p>
<h4 id="4-分区分段-索引"><a href="#4-分区分段-索引" class="headerlink" title="4.分区分段+索引"></a>4.分区分段+索引</h4><p><strong>Kafka的message是按topic分类存储的，topic中的数据又是按照一个一个的partition即分区存储到不同broker节点。每个partition对应了操作系统上的一个文件夹，partition实际上又是按照segment分段存储的。这也非常符合分布式系统分区分桶的设计思想。</strong><br>通过这种分区分段的设计，<strong>Kafka的message消息实际上是分布式存储在一个一个小的segment中的</strong>，每次文件操作也是直接操作的segment。为了进一步的查询优化，Kafka又默认为分段后的数据文件建立了索引文件，就是文件系统上的.index文件。这种分区分段+索引的设计，不仅提升了数据读取的效率，同时也提高了数据操作的并行度。</p>
<h4 id="5-批量读写"><a href="#5-批量读写" class="headerlink" title="5.批量读写"></a>5.批量读写</h4><p>假设网络带宽为10MB/S，一次性传输10MB的消息比传输1KB的消息10000万次显然要快得多。</p>
<h4 id="6-批量压缩"><a href="#6-批量压缩" class="headerlink" title="6.批量压缩"></a>6.批量压缩</h4><p>如果每个消息都压缩，但是压缩率相对很低，所以Kafka使用了批量压缩，即将多个消息一起压缩而不是单个消息压缩<br>Kafka允许使用递归的消息集合，批量的消息可以通过压缩的形式传输并且在日志中也可以保持压缩格式，直到被消费者解压缩<br>Kafka支持多种压缩协议，包括Gzip和Snappy压缩协议</p>
<h2 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h2><h3 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h3><p><img src="https://cdn.jsdelivr.net/gh/zheroic/zheroic.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/zheroic/BlogMedias/images/20200505173714.png" alt=""></p>
<h3 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h3><h4 id="HDFS中的block、packet、chunk"><a href="#HDFS中的block、packet、chunk" class="headerlink" title="HDFS中的block、packet、chunk"></a>HDFS中的block、packet、chunk</h4><p>block<br>文件上传前需要分块，这个块就是block，一般为128MB。它是最大的一个单位。</p>
<p>packet<br>packet是第二大的单位，它是client端向DataNode，或DataNode的PipLine之间传数据的基本单位，默认64KB。</p>
<p>chunk<br>chunk是最小的单位，它是client向DataNode，或DataNode的PipLine之间进行数据校验的基本单位，默认512Byte，因为用作校验，故每个chunk需要带有4Byte的校验位。所以实际每个chunk写入packet的大小为516Byte。由此可见真实数据与校验值数据的比值约为128 : 1。（即64*1024 / 512）</p>
<p>例如，在client端向DataNode传数据的时候，HDFSOutputStream会有一个chunk buff，写满一个chunk后，会计算校验和并写入当前的chunk。之后再把带有校验和的chunk写入packet，当一个packet写满后，packet会进入dataQueue队列，其他的DataNode就是从这个dataQueue获取client端上传的数据并存储的。同时一个DataNode成功存储一个packet后之后会返回一个ack packet，放入ack Queue中。</p>
<h4 id="HDFS写流程"><a href="#HDFS写流程" class="headerlink" title="HDFS写流程"></a>HDFS写流程</h4><p><img src="https://cdn.jsdelivr.net/gh/zheroic/zheroic.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/zheroic/BlogMedias/images/20200505173817.png" alt="3c9d415adbb29d3c21ce0f3eafa70d37.png"><br>1.client向NameNode发出写文件请求。<br>2.NameNode检查是否已存在文件、检查权限。若通过检查，直接先将操作写入EditLog，并返回输出流对象。<br>（注：WAL，write ahead log，先写Log，再写内存，因为EditLog记录的是最新的HDFS客户端执行所有的写操作。如果后续真实写操作失败了，由于在真实写操作之前，操作就被写入EditLog中了，故EditLog中仍会有记录，我们不用担心后续client读不到相应的数据块，因为在第5步中DataNode收到块后会有一返回确认信息，若没写成功，发送端没收到确认信息，会一直重试，直到成功）<br>3.client端按128MB的块切分文件。<br>4.client将NameNode返回的分配的可写的DataNode列表和Data数据一同发送给最近的第一个DataNode节点，此后client端和NameNode分配的多个DataNode构成pipeline管道，client端向输出流对象中写数据。client每向第一个DataNode写入一个packet，这个packet便会直接在pipeline里传给第二个、第三个…DataNode。<br>（注：并不是写好一个块或一整个文件后才向后分发）<br>5.每个DataNode写完一个packet后，会返回acks确认信息。<br>6.写完数据，关闭输出流。<br>7.client发送完成信号给NameNode。<br>（注：发送完成信号的时机取决于集群是强一致性还是最终一致性，强一致性则需要所有DataNode写完后才向NameNode汇报。最终一致性则其中任意一个DataNode写完后就能单独向NameNode汇报，HDFS一般情况下都是强调强一致性）</p>
<h4 id="HDFS读流程"><a href="#HDFS读流程" class="headerlink" title="HDFS读流程"></a>HDFS读流程</h4><p><img src="https://cdn.jsdelivr.net/gh/zheroic/zheroic.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/zheroic/BlogMedias/images/20200505173955.png" alt="6277e32d9c8cdf998116b59ecaf87fc8.png"><br>1.client访问NameNode，查询元数据信息，获得这个文件的数据块位置列表，返回输入流对象。<br>2.client就近挑选一台datanode服务器，请求建立输入流 。<br>3.DataNode向输入流中中写数据，以packet为单位来校验。<br>4.关闭输入流</p>
<h4 id="读写过程中数据完整性保证"><a href="#读写过程中数据完整性保证" class="headerlink" title="读写过程中数据完整性保证"></a>读写过程中数据完整性保证</h4><p>通过校验和。因为每个chunk中都有一个校验位，一个个chunk构成packet，一个个packet最终形成block，故可在block上求校验和。</p>
<p>HDFS 的client端即实现了对 HDFS 文件内容的校验和 (checksum) 检查。当客户端创建一个新的HDFS文件时候，分块后会计算这个文件每个数据块的校验和，此校验和会以一个隐藏文件形式保存在同一个 HDFS 命名空间下。当client端从HDFS中读取文件内容后，它会检查分块时候计算出的校验和（隐藏文件里）和读取到的文件块中校验和是否匹配，如果不匹配，客户端可以选择从其他 Datanode 获取该数据块的副本。</p>
<h3 id="数据倾斜"><a href="#数据倾斜" class="headerlink" title="数据倾斜"></a>数据倾斜</h3><h4 id="数据倾斜发生时的现象："><a href="#数据倾斜发生时的现象：" class="headerlink" title="数据倾斜发生时的现象："></a>数据倾斜发生时的现象：</h4><p>1、绝大多数task执行得都非常快，但个别task执行的极慢。<br>2、原本能正常执行的Spark作业，某天突然爆出OOM（内存溢出）异常。观察异常栈，是我们写的业务代码造成的</p>
<h4 id="数据倾斜发生的原理"><a href="#数据倾斜发生的原理" class="headerlink" title="数据倾斜发生的原理 :"></a>数据倾斜发生的原理 :</h4><p>在进行shuffle的时候，必须将各个节点上相同的Key拉取到某个节点上的一个task来进行处理，比如按照key进行聚合或者join操作。如果某个key对应的数据量特别大的话，会发生数据倾斜。比如大部分key对应的10条数据，但个别key却对应了100万条数据，那么大部分task会只分配到10条数据，而个别task可能会分配了100万数据。整个spark作业的运行进度是由运行时间最长的那个task决定的。<br>因此出现数据倾斜的时候，spark作业看起来会运行得非常缓慢，甚至可能因为某个task处理的数据量过大导致OOM。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title=" 解决方案"></a><u> 解决方案</u></h4><p>1、<strong>增加jvm内存</strong>,这适用于第一种情况(唯一值非常少，极少数值有非常多的记录值(唯一值少于几千)),这种情况下,往往只能通过硬件的手段来进行调优,增加jvm内存可以显著的提高运行效率。</p>
<p>2、<strong>增加reduce的个数</strong>,这适用于第二种情况(唯一值比较多，这个字段的某些值有远远多于其他值的记录数，但是它的占比也小于百分之一或千分之一),我们知道,这种情况下,最容易造成的结果就是大量相同key被partition到一个分区,从而一个reduce执行了大量的工作,而如果我们增加了reduce的个数,这种情况相对来说会减轻很多,毕竟计算的节点多了,就算工作量还是不均匀的,那也要小很多。</p>
<p>3、<strong>自定义分区</strong>,这需要用户自己继承partition类,指定分区策略,这种方式效果比较显著。</p>
<p>4、<strong>重新设计key</strong>,有一种方案是在map阶段时给key加上一个随机数,有了随机数的key就不会被大量的分配到同一节点(小几率),待到reduce后再把随机数去掉即可。</p>
<p>5、<strong>使用combinner合并</strong>,combinner是在map阶段,reduce之前的一个中间阶段,在这个阶段可以选择性的把大量的相同key数据先进行一个合并,可以看做是local reduce,然后再交给reduce来处理,这样做的好处很多,即减轻了map端向reduce端发送的数据量(减轻了网络带宽),也减轻了map端和reduce端中间的shuffle阶段的数据拉取数量(本地化磁盘IO速率),推荐使用这种方法。</p>
<h4 id="如何定位发生数据倾斜的代码"><a href="#如何定位发生数据倾斜的代码" class="headerlink" title="如何定位发生数据倾斜的代码"></a>如何定位发生数据倾斜的代码</h4><p>1、<strong>数据倾斜只会发生在shuffle中</strong>，下面是常用的可能会触发shuffle操作的算子：distinct、groupByKey、reduceByKey、aggregateByKey、join、cogroup、repartition等。出现数据倾斜时，可能就是代码中使用了这些算子的原因 </p>
<p>2、通过观察spark UI的节目定位数据倾斜发生在第几个stage中，如果是用yarn-client模式提交，那么本地是可以直接看到log的，可以在log中找到当前运行到了第几个stage;如果用yarn-cluster模式提交，可以通过Spark Web UI 来查看当前运行到了第几个stage。此外，无论是使用了yarn-client模式还是yarn-cluster模式，我们都可以在Spark Web UI 上深入看一下当前这个stage各个task分配的数据量，从而进一步确定是不是task分配的数据不均匀导致了数据倾斜。 </p>
<p>3、根据之前学的stage的划分算法定位到极有可能发生数据倾斜的代码</p>
<h4 id="详细解决方案"><a href="#详细解决方案" class="headerlink" title="详细解决方案"></a>详细解决方案</h4><h5 id="一、使用Hive-ETL-Extraction-Transformation-Loading-提取、转换和加载-预处理数据"><a href="#一、使用Hive-ETL-Extraction-Transformation-Loading-提取、转换和加载-预处理数据" class="headerlink" title="一、使用Hive ETL(Extraction-Transformation-Loading:提取、转换和加载) 预处理数据"></a>一、使用Hive ETL(Extraction-Transformation-Loading:提取、转换和加载) 预处理数据</h5><p>方案使用场景：<br>导致数据倾斜的是Hive表。如果该Hive表中的数据本身很不均匀，而且业务场景需要频繁的使用Spark对Hive表执行某个分析操作，那么比较适合使用这种技术方案。 </p>
<p>思路：<br>此时可以评估，是否可以通过Hive来进行数据预处理。即通过Hive ETL 预先对数据按照Key进行聚合，或者是预先和其他表进行join，然后再Spark作业中针对的数据源就是预处理后的Hive表。此时由于数据已经预先进行过聚合或者join操作了，那么在Spark作业中也就不需要使用原先的shuffle类算子执行这类操作了。 </p>
<p>原理：<br>从根源上解决了数据倾斜，因为彻底避免了在Spark中执行shuffle类算子。<br>但是因为毕竟数据本身就存在分布不均匀的问题，所以在Hive ETL中进行groubBy或者join等shuffle操作时，还是会发生数据倾斜，导致Hive ETL速度很慢。只是避免了Spark程序发生数据倾斜。 </p>
<p>经验：<br>在一些Java系统与Spark结合使用的项目中，会出现Java代码频繁调用Spark作业的场景，而且对Spark作业的执行性能要求很高，就比较适合使用这种方案。将数据倾斜提前到上游的Hive ETL，每天仅执行一次，只有那一次是比较慢的，而之后每次Java调用Spark作业时，执行速度都会很快，能够提供更好的用户体验。</p>
<h5 id="二、过滤少数导致倾斜的key"><a href="#二、过滤少数导致倾斜的key" class="headerlink" title="二、过滤少数导致倾斜的key"></a>二、过滤少数导致倾斜的key</h5><p>方案使用场景：<br>若发现导致倾斜的key就少数几个，并且对计算本身的影响并不大。比如99%的key对应10条数据，但只有一个key对应100万数据。 </p>
<p>思路：<br>若判断少数几个数据量特别多的key对作业的执行和计算结果不是那么特别重要，可以直接过滤掉那几个key。如在Spark SQL中就可以使用where子句过滤掉这些key,或者在Spark Core 中对RDD执行filter算子过滤掉这些key。如果需要每次作业执行时，动态判定哪些key的数据量最多然后过滤，可以使用sample算子对RDD进行采样，然后计算每个key的数量，取数据量最多的key过滤即可。 </p>
<p>缺点：<br>适用场景不多，大多数情况下，导致倾斜的key还是很多的，并不是只有少数几个。</p>
<h5 id="三、提高shuffle操作的并行度"><a href="#三、提高shuffle操作的并行度" class="headerlink" title="三、提高shuffle操作的并行度"></a>三、提高shuffle操作的并行度</h5><p>方案使用场景：<br>若我们必须要面对数据倾斜问题，要这么使用。 </p>
<p>思路：<br>在对RDD执行shuffle算子时，给shuffle算子传入一个参数，如reduceByKey（1000），该参数设置了这个shuffle算子执行时shuffle read task 的数量。对于Spark SQL中的shuffle类语句，如 groupBy 、join 等需要设置一个参数，即spark.sql.shuffle.partitions。该参数代表了shuffle read task 的并行度，默认值是200。 </p>
<p>原理：<br>增加shuffle read task 的数量，可以让原本分配给一个task的多个key分配给多个task，从而让每个task处理比原来更少的数据。举例来说，如果原本有5个key，每个key对应10条数据，这5个key都是分配给一个task的，那么这个task就要处理50条数据。而增加了shuffle read task以后，每个task就分配到一个key，即每个task就处理10条数据，那么自然每个task的执行时间都会变短了。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/zheroic/zheroic.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/zheroic/BlogMedias/images/20200505174103.png" alt=""></p>
<p>实现起来比较简单，可以有效缓解和减轻数据倾斜的影响。<br>只是缓解了数据倾斜而已，没有彻底根除问题，根据实践经验来看，其效果有限。</p>
<h5 id="四、两阶段聚合（局部聚合-全局聚合）"><a href="#四、两阶段聚合（局部聚合-全局聚合）" class="headerlink" title="四、两阶段聚合（局部聚合+全局聚合）"></a>四、两阶段聚合（局部聚合+全局聚合）</h5><p>方案使用场景：<br>对RDD执行reduceByKey等聚合类shuffle算子或者在Spark SQL中使用group by语句进行分组聚合时，比较适用这种方案。 </p>
<p>思路：<br>这个方案的核心实现思路就是进行两阶段聚合。第一次是局部聚合，先给每个key都打上一个随机数，比如10以内的随机数，此时原先一样的key就变成不一样的了，比如(hello, 1) (hello, 1) (hello, 1) (hello, 1)，就会变成(1_hello, 1) (1_hello, 1) (2_hello, 1) (2_hello, 1)。接着对打上随机数后的数据，执行reduceByKey等聚合操作，进行局部聚合，那么局部聚合结果，就会变成了(1_hello, 2) (2_hello, 2)。然后将各个key的前缀给去掉，就会变成(hello,2)(hello,2)，再次进行全局聚合操作，就可以得到最终结果了，比如(hello, 4)。 </p>
<p>方案优点：<br>对于聚合类的shuffle操作导致的数据倾斜，效果是非常不错的。通常都可以解决掉数据倾斜，或者至少是大幅度缓解数据倾斜，将Spark作业的性能提升数倍以上。 </p>
<p>方案缺点：<br>仅仅适用于聚合类的shuffle操作，适用范围相对较窄。如果是join类的shuffle操作，还得用其他的解决方案。</p>
<h5 id="五、将reduce-join-转为map-join"><a href="#五、将reduce-join-转为map-join" class="headerlink" title="五、将reduce join 转为map join"></a>五、将reduce join 转为map join</h5><p>方案使用场景：<br>在对RDD使用join类操作，或者是在Spark SQL中使用join语句时，而且join操作中的一个RDD<br>或表的数据量比较小（几百M或者一两G）。 </p>
<p>实现思路：<br>不使用join算子进行连接操作，而使用Broadcast变量与map类算子实现join操作，进而完全规避掉shuffle类操作，彻底避免数据倾斜的发生和出现。将较小RDD中的数据直接通过collect算子拉取到Driver端的内存中来，然后对其创建一个Broadcast变量；接着对另外RDD执行map类算子，在算子函数内，从Broadcast变量中获取较小RDD 的全量数据，与当前RDD的每一条数据按照连接key进行比对，如果连接key相同的话，那么就将两个RDD的数据用你需要的方式连接起来。 </p>
<p>实现原理：<br>普通的join是会走shuffle过程的，而一旦shuffle，就相当于会将相同key的数据拉取到一个shuffle read task中再进行join，此时就是reduce join。但是如果一个RDD是比较小的，则可以采用广播小RDD全量数据+map算子来实现与join同样的效果，也就是mao join ，而此时不会发生shuffle操作，也就不会发生数据倾斜。 </p>
<p>方案优点：<br>对join操作导致的数据倾斜，效果非常好，因为根本就不会发生shuffle，也就根本不会发生数据倾斜。 </p>
<p>方案缺点：<br>适用场景较少，因为这个方案只适用于一个大表和一个小表的情况。毕竟我们需要将小表进行广播，此时会比较消耗内存资源，driver和每个Executor内存中都会驻留一份小RDD的全量数据。如果我们广播出去的RDD数据比较大，比如10G以上，那么就可能发生内存溢出了。因此并不适合两个都是大表的情况。</p>
<h5 id="六、采样倾斜key并分拆join操作"><a href="#六、采样倾斜key并分拆join操作" class="headerlink" title="六、采样倾斜key并分拆join操作"></a>六、采样倾斜key并分拆join操作</h5><p>方案使用场景:<br>两个RDD/Hive表进行join的时候，如果数据量都比较大，无法采用上第五点解决方案，那么此时可以看一下两个RDD/Hive表中key的分布情况，若出现数据倾斜，是因为其中某一个RDD/Hive表中的少数几个key的数据量过大，而另一个中的所有key都分布比较均匀，那么采用这个解决方案是比较合适的。 </p>
<p>实现思路:<br>对包含少数几个数据量过大的key的那个RDD，通过sample算子采样出一份样本来，然后统计一下每个key的数据量，计算出数据量最大的是哪几个key。<br>然后将这几个key对应数据从原来的RDD中拆分出来，形成一个单独的RDD，并给每个key打上n以内的随机数作为前缀，而不会导致倾斜的大部分key形成另外一个RDD。</p>
<p>接着将需要join的另一个RDD，也就是过滤出来的那几个倾斜key对应的数据并形成一个单独的RDD，将每条数据膨胀成n条数据，这n条数据都按顺序附加一个0~n的前缀，不会导致倾斜的大部分key也形成另外一个RDD<br>（此时一共生存了四个RDD：两个key有倾斜的RDD，两个正常RDD）<br>再将附加了随机前缀的独立RDD与另一个膨胀n倍的独立RDD进行join，此时就可以将原先相同的key打散成n份，分散到多个task中去进行join。<br>而另外两普通的RDD就照常join即可。<br>最后将两次join的结果使用union算子合并起来即可。<img src="https://cdn.jsdelivr.net/gh/zheroic/zheroic.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/zheroic/BlogMedias/images/20200505174207.png" alt=""><br>原理：<br>对于join导致的数据倾斜，如果只是某几个key导致了倾斜，可以将少数几个key拆分为独立RDD，并附加随机前缀打散成n份去进行join，此时这几个key对于的数据就不会集中在少数几个task上，而是分散到多个task进行join。 </p>
<p>优点:<br>对于join导致的数据倾斜，如果只是某几个key导致了倾斜，此方法可以用最有效的方式打散key进行join，且只需要针对少数倾斜的key对应的数据进行扩容n倍，不需要对全量数据进行扩容，避免占用过多内存。 </p>
<p>缺点:<br>若key特别多，则不合适。</p>
<h5 id="七、使用随机前缀和扩容RDD进行join"><a href="#七、使用随机前缀和扩容RDD进行join" class="headerlink" title="七、使用随机前缀和扩容RDD进行join"></a>七、使用随机前缀和扩容RDD进行join</h5><p>方案使用场景:<br>若在进行join操作时，RDD中有大量的key导致数据倾斜的时候。 </p>
<p>思路:<br>首先查看RDD／Hive表中的数据分布情况，找到造成数据倾斜的RDD/Hive表，比如有多个key都对应了万条数据。<br>然后将该RDD 的每条数据都打上一个n以内的随即前缀。<br>同时对另外一个正常的RDD进行扩容，将每条数据都扩容成n条数据，扩容出来的每条数据都依次打上一个0~n的前缀<br>最后将两个处理后的RDD进行join即可。 </p>
<p>原理:<br>将原先一样的key通过附加前缀变成不一样的key，然后就看可以将这些处理后的“不同的key”分散到多个task中那个去处理，而不是让一个task去处理大量相同的key。此方法与方法六的区别在于，有大量倾斜key的情况，没法将部分key拆分出来单独处理，因此只能对整个RDD 进行数据扩容，对资源要求很高。 </p>
<p>缺点:<br>更多的是缓解数据倾斜，而不是彻底避免，而且需要对整个RDD进行扩容，对内存资源要求较高。</p>
<h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p><strong>MySQL中的索引的存储类型有两种：B+TREE、HASH</strong>,hash索引适合单值查询，b+tree索引既适合单值查询又适合范围查询</p>
<h4 id="MySQL中索引的优点和缺点和使用原则"><a href="#MySQL中索引的优点和缺点和使用原则" class="headerlink" title="MySQL中索引的优点和缺点和使用原则　　　"></a>MySQL中索引的优点和缺点和使用原则　　　</h4><p>优点：　　　<br>1、所有的MySql列类型(字段类型)都可以被索引，也就是可以给任意字段设置索引　　　<br>2、大大加快数据的查询速度　　　<br>缺点：　　　<br>1、创建索引和维护索引要耗费时间，并且随着数据量的增加所耗费的时间也会增加　　　<br>2、索引也需要占空间，我们知道数据表中的数据也会有最大上线设置的，如果我们有大量的索引，索引文件可能会比数据文件更快达到上线值　　　<br>3、当对表中的数据进行增加、删除、修改时，索引也需要动态的维护，降低了数据的维护速度。<br>使用原则：　　　<br>通过上面说的优点和缺点，我们应该可以知道，并不是每个字段度设置索引就好，也不是索引越多越好，而是需要自己合理的使用。　　　<br>1、对经常更新的表就避免对其进行过多的索引，对经常用于查询的字段应该创建索引</p>
<p>2、数据量小的表最好不要使用索引，因为由于数据较少，可能查询全部数据花费的时间比遍历索引的时间还要短，索引就可能不会产生优化效果。　　<br>3、在一同值少的列上(字段上)不要建立索引，比如在学生表的”性别”字段上只有男，女两个不同值。相反的，在一个字段上不同值较多可以建立索引。</p>
<h4 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h4><p><strong>索引是在存储引擎中实现的，也就是说不同的存储引擎，会使用不同的索引</strong></p>
<p>1.索引我们分为四类来讲 单列索引(普通索引，唯一索引，主键索引)、组合索引、全文索引、空间索引、　　      </p>
<ul>
<li><p>1.1、单列索引：一个索引只包含单个列，但一个表中可以有多个单列索引。</p>
<ul>
<li>1.1.1、普通索引：MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了查询数据更快一点。　　　　   </li>
<li>1.1.2、唯一索引：索引列中的值必须是唯一的，但是允许为空值，　　　　   </li>
<li>1.1.3、主键索引：是一种特殊的唯一索引，不允许有空值。　　      </li>
</ul>
</li>
<li><p>1.2、组合索引:在表中的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时遵循最左前缀集合。</p>
</li>
<li><p>1.3、全文索引:全文索引，只有在MyISAM引擎上才能使用，只能在CHAR,VARCHAR,TEXT类型字段上使用全文索引，介绍了要求，说说什么是全文索引，就是在一堆文字中，通过其中的某个关键字等，就能找到该字段所属的记录行，比如有”你是个靓仔，靓女 …” 通过靓仔，可能就可以找到该条记录。这里说的是可能，因为全文索引的使用涉及了很多细节，我们只需要知道这个大概意思，</p>
</li>
<li><p>1.4、空间索引:空间索引是对空间数据类型的字段建立的索引，MySQL中的空间数据类型有四种，GEOMETRY、POINT、LINESTRING、POLYGON。在创建空间索引时，使用SPATIAL关键字。要求，引擎为MyISAM，创建空间索引的列，必须将其声明为NOT NULL。</p>
<h4 id="联合索引最左匹配原则"><a href="#联合索引最左匹配原则" class="headerlink" title="联合索引最左匹配原则"></a>联合索引最左匹配原则</h4><p>索引的底层是一颗B+树，那么联合索引当然还是一颗B+树，只不过联合索引的健值数量不是一个，而是多个。构建一颗B+树只能根据一个值来构建，因此数据库依据联合索引最左的字段来构建B+树。<br>例子：假如创建一个（a,b)的联合索引，那么它的索引树是这样的<br><img src="https://cdn.jsdelivr.net/gh/zheroic/zheroic.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/zheroic/BlogMedias/images/20200505174240.png" alt="ea26ec6f5e83b7dbeed1287b44210a8b.png"></p>
</li>
</ul>
<p>可以看到a的值是有顺序的，1，1，2，2，3，3，而b的值是没有顺序的1，2，1，4，1，2。所以b = 2这种查询条件没有办法利用索引，因为联合索引首先是按a排序的，b是无序的。</p>
<p>同时我们还可以发现在a值相等的情况下，b值又是按顺序排列的，但是这种顺序是相对的。所以最左匹配原则遇上范围查询就会停止，剩下的字段都无法使用索引。例如a = 1 and b = 2 a,b字段都可以使用索引，因为在a值确定的情况下b是相对有序的，而a&gt;1and b=2，a字段可以匹配上索引，但b值不可以，因为a的值是一个范围，在这个范围中b是无序的。</p>
<p><strong>最左匹配原则：最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(&gt;、&lt;、between、like)就会停止匹配。</strong></p>
<p> 假如建立联合索引（a,b,c）</p>
<p>1 全值匹配查询时</p>
<pre><code>select * from table_name where a = '1' and b = '2' and c = '3' 
select * from table_name where b = '2' and a = '1' and c = '3' 
select * from table_name where c = '3' and b = '2' and a = '1' 
......</code></pre><p>用到了索引</p>
<p>where子句几个搜索条件顺序调换不影响查询结果，因为Mysql中有查询优化器，会自动优化查询顺序 </p>
<p>2 匹配左边的列时</p>
<pre><code>select * from table_name where a = '1' 
select * from table_name where a = '1' and b = '2'  
select * from table_name where a = '1' and b = '2' and c = '3'</code></pre><p>都从最左边开始连续匹配，用到了索引</p>
<pre><code>select * from table_name where  b = '2' 
select * from table_name where  c = '3'
select * from table_name where  b = '1' and c = '3' </code></pre><p>这些没有从最左边开始，最后查询没有用到索引，用的是全表扫描 </p>
<pre><code>select * from table_name where a = '1' and c = '3' </code></pre><p>如果不连续时，只用到了a列的索引，b列和c列都没有用到 </p>
<p> 3 匹配列前缀</p>
<p>如果列是字符型的话它的比较规则是先比较字符串的第一个字符，第一个字符小的哪个字符串就比较小，如果两个字符串第一个字符相通，那就再比较第二个字符，第二个字符比较小的那个字符串就比较小，依次类推，比较字符串。</p>
<p>如果a是字符类型，那么前缀匹配用的是索引，后缀和中缀只能全表扫描了</p>
<pre><code>select * from table_name where a like 'As%'; //前缀都是排好序的，走索引查询
select * from table_name where  a like '%As'//全表查询
select * from table_name where  a like '%As%'//全表查询</code></pre><p>4 匹配范围值</p>
<pre><code>select * from table_name where  a &gt; 1 and a &lt; 3</code></pre><p>可以对最左边的列进行范围查询</p>
<pre><code>select * from table_name where  a &gt; 1 and a &lt; 3 and b &gt; 1;</code></pre><p>多个列同时进行范围查找时，只有对索引最左边的那个列进行范围查找才用到B+树索引，也就是只有a用到索引，在1&lt;a&lt;3的范围内b是无序的，不能用索引，找到1&lt;a&lt;3的记录后，只能根据条件 b &gt; 1继续逐条过滤</p>
<p> 5 精确匹配某一列并范围匹配另外一列</p>
<p>如果左边的列是精确查找的，右边的列可以进行范围查找</p>
<pre><code>select * from table_name where  a = 1 and b &gt; 3;</code></pre><p> a=1的情况下b是有序的，进行范围查找走的是联合索引</p>
<p>6 排序</p>
<p>一般情况下，我们只能把记录加载到内存中，再用一些排序算法，比如快速排序，归并排序等在内存中对这些记录进行排序，有时候查询的结果集太大不能在内存中进行排序的话，还可能暂时借助磁盘空间存放中间结果，排序操作完成后再把排好序的结果返回客户端。Mysql中把这种再内存中或磁盘上进行排序的方式统称为文件排序。文件排序非常慢，但如果order子句用到了索引列，就有可能省去文件排序的步骤</p>
<pre><code>select * from table_name order by a,b,c limit 10;</code></pre><p>因为b+树索引本身就是按照上述规则排序的，所以可以直接从索引中提取数据，然后进行回表操作取出该索引中不包含的列就好了</p>
<p>order by的子句后面的顺序也必须按照索引列的顺序给出，比如</p>
<pre><code>select * from table_name order by b,c,a limit 10;</code></pre><p> 这种颠倒顺序的没有用到索引</p>
<pre><code>select * from table_name order by a limit 10;
select * from table_name order by a,b limit 10;</code></pre><p>这种用到部分索引</p>
<pre><code>select * from table_name where a =1 order by b,c limit 10;</code></pre><p>联合索引左边列为常量，后边的列排序可以用到索引</p>
<h4 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h4><p>（1）条件是or,如果还想让or条件生效，给or每个字段加上索引</p>
<p>（2）like查询，以%开头</p>
<p>（3）内部函数</p>
<p>（4）对索引列进行计算</p>
<p>（5）is null不会用，is not null 会用</p>
<h3 id="Join"><a href="#Join" class="headerlink" title="Join"></a>Join</h3><ul>
<li>INNER JOIN（内连接，或等值连接）：获取两个表中字段匹配关系的记录；</li>
<li>LEFT JOIN（左连接）：获取左表中的所有记录，即使在右表没有对应匹配的记录；</li>
<li>RIGHT JOIN（右连接）：与 LEFT JOIN 相反，用于获取右表中的所有记录，即使左表没有对应匹配的记录。</li>
</ul>
<p>现有两个表，本节后续的用法示例，均是对这两个表进行操作的，表的信息如下：</p>
<pre><code>mysql&gt; select * from roles;
+---------+------------+----------+
| role_id | occupation | camp     |
+---------+------------+----------+
|       1 | warrior    | alliance |
|       2 | paladin    | alliance |
|       3 | rogue      | Horde    |
+---------+------------+----------+
3 rows in set (0.01 sec)

mysql&gt; 
mysql&gt; select * from mount_info;
+----------+------------+---------+
| mount_id | mount_name | role_id |
+----------+------------+---------+
|        1 | horse      |       1 |
|        2 | sheep      |       1 |
|        3 | sheep      |       4 |
+----------+------------+---------+
3 rows in set (0.01 sec)</code></pre><h4 id="INNER-JOIN-join"><a href="#INNER-JOIN-join" class="headerlink" title="INNER JOIN=join"></a>INNER JOIN=join</h4><pre><code>mysql&gt; SELECT a.role_id, a.occupation, a.camp, b.mount_name FROM roles a INNER JOIN mount_info b ON a.role_id = b.role_id;
//等价于：
SELECT a.role_id, a.occupation, a.camp, b.mount_name FROM roles a, mount_info b WHERE a.role_id = b.role_id;
+---------+------------+----------+------------+
| role_id | occupation | camp     | mount_name |
+---------+------------+----------+------------+
|       1 | warrior    | alliance | horse      |
|       1 | warrior    | alliance | sheep      |
+---------+------------+----------+------------+
2 rows in set (0.01 sec)</code></pre><p>INNER JOIN 的表关联模型如下：<img src="https://cdn.jsdelivr.net/gh/zheroic/zheroic.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/zheroic/BlogMedias/images/20200505174315.png" alt="941fde446161f80e9ba1c451eac1b34b.png"><br>上图中绿色的部分，为两表的内关联结果。</p>
<h4 id="LEFT-JOIN"><a href="#LEFT-JOIN" class="headerlink" title="LEFT JOIN"></a>LEFT JOIN</h4><pre><code>mysql&gt; SELECT a.role_id, a.occupation, a.camp, b.mount_name FROM roles a LEFT JOIN mount_info b ON a.role_id = b.role_id;
+---------+------------+----------+------------+
| role_id | occupation | camp     | mount_name |
+---------+------------+----------+------------+
|       1 | warrior    | alliance | horse      |
|       1 | warrior    | alliance | sheep      |
|       2 | paladin    | alliance | NULL       |
|       3 | rogue      | Horde    | NULL       |
+---------+------------+----------+------------+
4 rows in set (0.01 sec)

在上述结果中能够看到，上面执行的SQL语句读取左边的数据表 roles 的所有的（SELECT）字段数据，即使在右侧表 mount_info 中没有对应的 role_id 字段值。</code></pre><p>LEFT JOIN 的表关联模型如下：<img src="https://cdn.jsdelivr.net/gh/zheroic/zheroic.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/zheroic/BlogMedias/images/20200505174351.png" alt="1074641fc4c57c943698d87aad585be4.png"><br>上图中绿色的部分，为两表的左关联结果。</p>
<h4 id="RIGHT-JOIN"><a href="#RIGHT-JOIN" class="headerlink" title="RIGHT JOIN"></a>RIGHT JOIN</h4><pre><code>mysql&gt; SELECT a.role_id, a.occupation, a.camp, b.mount_name FROM roles a RIGHT JOIN mount_info b ON a.role_id = b.role_id;
+---------+------------+----------+------------+
| role_id | occupation | camp     | mount_name |
+---------+------------+----------+------------+
|       1 | warrior    | alliance | horse      |
|       1 | warrior    | alliance | sheep      |
|    NULL | NULL       | NULL     | sheep      |
+---------+------------+----------+------------+
3 rows in set (0.01 sec)


在上述结果中能够看到，上面执行的SQL语句读取右侧的数据表 mount_info 的所有的（SELECT）字段数据，即使在左侧表 roles 中没有对应的 role_id 字段值。</code></pre><p>RIGHT JOIN 的表关联模型如下：<img src="https://cdn.jsdelivr.net/gh/zheroic/zheroic.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/zheroic/BlogMedias/images/20200505174642.png" alt="46d3f71aeacf5f75815dbc2901dc0fd1.png"><br>上图中绿色的部分，为两表的右关联结果。</p>
<h3 id="Union"><a href="#Union" class="headerlink" title="Union"></a>Union</h3><p>union 缺省在合并结果集后消除重复项,</p>
<p>union all 指定在合并结果集后保留重复项, </p>
<pre><code>比如A表的数据是 A{ 1,4,5,9} B{2,3,4,5}

那我执行此语句 select * from A union select * from B 那结果是{1,2,3,4,5,9}

如果执行select * from A union all select * from B 结果是{1,2,3,4,4,5,5,9}</code></pre><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>1.共享锁/排他锁<br>  共享锁和排他锁是从同一时刻是否允许多个线程持有该锁的角度来划分。<br>  共享锁允许同一时刻多个线程进入持有锁，访问临界区资源。而排他锁就是通常意义上的锁，同一时刻只允许一个线程访问临界资源。对于共享锁，主要是指对数据库读操作中的读锁，在读写资源的时候如果没有线程持有写锁和请求写锁，则此时允许多个线程持有读锁。<br>2.乐观锁/悲观锁<br>  主要用于数据库数据的操作中，而对于线程锁中较为少见。<br>  悲观锁和乐观锁是一种加锁思想。<br>  对于乐观锁，在进行数据读取的时候不会加锁，而在进行写入操作的时候会判断一下数据是否被其它线程修改过，如果修改则更新数据，如果没有则继续进行数据写入操作。乐观锁不是系统中自带的锁，而是一种数据读取写入思想。应用场景例如：在向数据库中插入数据的时候，先从数据库中读取记录修改版本标识字段，如果该字段没有发生变化（没有其他线程对数据进行写操作）则执行写入操作，如果发生变化则重新计算数据。<br>  对于悲观锁，无论是进行读操作还是进行写操作都会进行加锁操作。对于悲观锁，如果并发量较大则比较耗费资源，当然保证了数据的安全性。</p>
<h3 id="Mysql事务四大特性"><a href="#Mysql事务四大特性" class="headerlink" title="Mysql事务四大特性"></a>Mysql事务四大特性</h3><p><code>原子性</code>、<code>一致性</code>、<code>隔离性</code>、<code>持久性</code>，下面再对这事务的四大特性做一个描述</p>
<ul>
<li><code>原子性(Atomicity)</code>: 原子性指的就是 MySQL 中的包含事务的操作要么<code>全部成功</code>、要么全部<code>失败回滚</code>，因此事务的操作如果成功就必须要全部应用到数据库，如果操作失败则不能对数据库有任何影响。</li>
</ul>
<blockquote>
<p>“</p>
<p>这里涉及到一个概念，什么是 MySQL 中的事务？</p>
<p>事务是一组操作，组成这组操作的各个单元，要不全都成功要不全都失败，这个特性就是事务。</p>
<p>在 MySQL 中，事务是在引擎层实现的，只有使用 <code>innodb</code> 引擎的数据库或表才支持事务。</p>
</blockquote>
<ul>
<li><code>一致性(Consistency)</code>：一致性指的是一个事务在执行前后其状态一致。比如 A 和 B 加起来的钱一共是 1000 元，那么不管 A 和 B 之间如何转账，转多少次，事务结束后两个用户的钱加起来还得是 1000，这就是事务的一致性。</li>
<li><code>持久性(Durability)</code>: 持久性指的是一旦事务提交，那么发生的改变就是永久性的，即使数据库遇到特殊情况比如故障的时候也不会产生干扰。</li>
<li><code>隔离性(Isolation)</code>：隔离性需要重点说一下，当多个事务同时进行时，就有可能出现<code>脏读(dirty read)</code>、<code>不可重复读(non-repeatable read)</code>、<code>幻读(phantom read)</code> 的情况，为了解决这些并发问题，提出了隔离性的概念。</li>
</ul>
<blockquote>
<p>“</p>
<p>脏读：事务 A 读取了事务 B 更新后的数据，但是事务 B 没有提交，然后事务 B 执行回滚操作，那么事务 A 读到的数据就是脏数据</p>
<p>不可重复读：事务 A 进行多次读取操作，事务 B 在事务 A 多次读取的过程中执行更新操作并提交，提交后事务 A 读到的数据不一致。</p>
<p>幻读：事务 A 将数据库中所有学生的成绩由 A -&gt; B，此时事务 B 手动插入了一条成绩为 A 的记录，在事务 A 更改完毕后，发现还有一条记录没有修改，那么这种情况就叫做出现了幻读。</p>
</blockquote>
<h3 id="SQL隔离级别"><a href="#SQL隔离级别" class="headerlink" title="SQL隔离级别"></a>SQL隔离级别</h3><p>SQL的隔离级别有四种，它们分别是<code>读未提交(read uncommitted)</code>、<code>读已提交(read committed)</code>、<code>可重复读(repetable read)</code> 和 <code>串行化(serializable)</code>。下面分别来解释一下。</p>
<p>读未提交：读未提交指的是一个事务在提交之前，它所做的修改就能够被其他事务所看到。</p>
<p>读已提交：读已提交指的是一个事务在提交之后，它所做的变更才能够让其他事务看到。</p>
<p>可重复读：可重复读指的是一个事务在执行的过程中，看到的数据是和启动时看到的数据是一致的。未提交的变更对其他事务不可见。</p>
<p>串行化：顾名思义是对于同一行记录，<code>写</code>会加<code>写锁</code>，<code>读</code>会加<code>读锁</code>。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</p>
<p>这四个隔离级别可以解决脏读、不可重复读、幻象读这三类问题。总结如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/zheroic/zheroic.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/zheroic/BlogMedias/images/20200509104419.jpg" alt=""></p>
<p>其中隔离级别由低到高是：读未提交 &lt; 读已提交 &lt; 可重复读 &lt; 串行化</p>
<p>隔离级别越高，越能够保证数据的完整性和一致性，但是对并发的性能影响越大。大多数数据库的默认级别是<code>读已提交(Read committed)</code>，比如 Sql Server、Oracle ，但是 MySQL 的默认隔离级别是 <code>可重复读(repeatable-read)</code>。</p>
<h3 id="MySQL-常见存储引擎的区别"><a href="#MySQL-常见存储引擎的区别" class="headerlink" title="MySQL 常见存储引擎的区别"></a>MySQL 常见存储引擎的区别</h3><p>MySQL 常见的存储引擎，可以使用</p>
<pre><code>SHOW ENGINES</code></pre><p>命令，来列出所有的存储引擎</p>
<p><img src="https://cdn.jsdelivr.net/gh/zheroic/zheroic.github.io/images/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdUjIID8CJZm0kCpUTFyVGvJznoR5W4Rxsh0whBL1ls2BtrxR4GgwRndwMbEy7GSy8dicaCCFuNqQJg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=""></p>
<p>可以看到，InnoDB 是 MySQL 默认支持的存储引擎，支持<strong>事务、行级锁定和外键</strong>。</p>
<h4 id="MyISAM-存储引擎的特点"><a href="#MyISAM-存储引擎的特点" class="headerlink" title="MyISAM 存储引擎的特点"></a>MyISAM 存储引擎的特点</h4><p>在 5.1 版本之前，MyISAM 是 MySQL 的默认存储引擎，MyISAM 并发性比较差，使用的场景比较少，主要特点是</p>
<ul>
<li><p>不支持<code>事务</code>操作，ACID 的特性也就不存在了，这一设计是为了性能和效率考虑的。</p>
</li>
<li><p>不支持<code>外键</code>操作，如果强行增加外键，MySQL 不会报错，只不过外键不起作用。</p>
</li>
<li><p>MyISAM 默认的锁粒度是<code>表级锁</code>，所以并发性能比较差，加锁比较快，锁冲突比较少，不太容易发生死锁的情况。</p>
</li>
<li><p>MyISAM 会在磁盘上存储三个文件，文件名和表名相同，扩展名分别是 <code>.frm(存储表定义)</code>、<code>.MYD(MYData,存储数据)</code>、<code>MYI(MyIndex,存储索引)</code>。这里需要特别注意的是 MyISAM 只缓存<code>索引文件</code>，并不缓存数据文件。</p>
</li>
<li><p>MyISAM 支持的索引类型有 <code>全局索引(Full-Text)</code>、<code>B-Tree 索引</code>、<code>R-Tree 索引</code></p>
<p>Full-Text 索引：它的出现是为了解决针对文本的模糊查询效率较低的问题。</p>
<p>B-Tree 索引：所有的索引节点都按照平衡树的数据结构来存储，所有的索引数据节点都在叶节点</p>
<p>R-Tree索引：它的存储方式和 B-Tree 索引有一些区别，主要设计用于存储空间和多维数据的字段做索引,目前的 MySQL 版本仅支持 geometry 类型的字段作索引，相对于 BTREE，RTREE 的优势在于范围查找。</p>
</li>
<li><p>数据库所在主机如果宕机，MyISAM 的数据文件容易损坏，而且难以恢复。</p>
</li>
<li><p>增删改查性能方面：SELECT 性能较高，适用于查询较多的情况</p>
</li>
</ul>
<h4 id="InnoDB-存储引擎的特点"><a href="#InnoDB-存储引擎的特点" class="headerlink" title="InnoDB 存储引擎的特点"></a>InnoDB 存储引擎的特点</h4><p>自从 MySQL 5.1 之后，默认的存储引擎变成了 InnoDB 存储引擎，相对于 MyISAM，InnoDB 存储引擎有了较大的改变，它的主要特点是</p>
<ul>
<li>支持事务操作，具有事务 ACID 隔离特性，默认的隔离级别是<code>可重复读(repetable-read)</code>、通过MVCC（并发版本控制）来实现的。能够解决<code>脏读</code>和<code>不可重复读</code>的问题。</li>
<li>InnoDB 支持外键操作。</li>
<li>InnoDB 默认的锁粒度<code>行级锁</code>，并发性能比较好，会发生死锁的情况。</li>
<li>和 MyISAM 一样的是，InnoDB 存储引擎也有 <code>.frm文件存储表结构</code> 定义，但是不同的是，InnoDB 的表数据与索引数据是存储在一起的，都位于 B+ 数的叶子节点上，而 MyISAM 的表数据和索引数据是分开的。</li>
<li>InnoDB 有安全的日志文件，这个日志文件用于恢复因数据库崩溃或其他情况导致的数据丢失问题，保证数据的一致性。</li>
<li>InnoDB 和 MyISAM 支持的索引类型相同，但具体实现因为文件结构的不同有很大差异。</li>
<li>增删改查性能方面，如果执行大量的增删改操作，推荐使用 InnoDB 存储引擎，它在删除操作时是对行删除，不会重建表。</li>
</ul>
<h4 id="MyISAM-和-InnoDB-存储引擎的对比"><a href="#MyISAM-和-InnoDB-存储引擎的对比" class="headerlink" title="MyISAM 和 InnoDB 存储引擎的对比"></a>MyISAM 和 InnoDB 存储引擎的对比</h4><ul>
<li><code>锁粒度方面</code>：由于锁粒度不同，InnoDB 比 MyISAM 支持更高的并发；InnoDB 的锁粒度为行锁、MyISAM 的锁粒度为表锁、行锁需要对每一行进行加锁，所以锁的开销更大，但是能解决脏读和不可重复读的问题，相对来说也更容易发生死锁</li>
<li><code>可恢复性上</code>：由于 InnoDB 是有事务日志的，所以在产生由于数据库崩溃等条件后，可以根据日志文件进行恢复。而 MyISAM 则没有事务日志。</li>
<li><code>查询性能上</code>：MyISAM 要优于 InnoDB，因为 InnoDB 在查询过程中，是需要维护数据缓存，而且查询过程是先定位到行所在的数据块，然后在从数据块中定位到要查找的行；而 MyISAM 可以直接定位到数据所在的内存地址，可以直接找到数据。</li>
<li><code>表结构文件上</code>：MyISAM 的表结构文件包括：.frm(表结构定义),.MYI(索引),.MYD(数据)；而 InnoDB 的表数据文件为:.ibd和.frm(表结构定义)；</li>
</ul>
<h3 id="MySQL-基础架构"><a href="#MySQL-基础架构" class="headerlink" title="MySQL 基础架构"></a>MySQL 基础架构</h3><p>这道题应该从 MySQL 架构来理解，我们可以把 MySQL 拆解成几个零件，如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/zheroic/zheroic.github.io/images/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdUjIID8CJZm0kCpUTFyVGvJ13HiclXviaTmLpxK5X6jAb1fd52iaMg70YuvzRoH2cfIudw3PGgyAp7AA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>大致上来说，MySQL 可以分为 <code>Server</code>层和 <code>存储引擎</code>层。</p>
<p>Server 层包括连接器、查询缓存、分析器、优化器、执行器，包括大多数 MySQL 中的核心功能，所有跨存储引擎的功能也在这一层实现，包括 <strong>存储过程、触发器、视图等</strong>。</p>
<p>存储引擎层包括 MySQL 常见的存储引擎，包括 <strong>MyISAM、InnoDB 和 Memory</strong> 等，最常用的是 InnoDB，也是现在 MySQL 的默认存储引擎。存储引擎也可以在创建表的时候手动指定，比如下面</p>
<pre><code>CREATE TABLE t (i INT) ENGINE = &lt;Storage Engine&gt;;</code></pre><p>然后我们就可以探讨 MySQL 的执行过程了</p>
<h4 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h4><p>首先需要在 MySQL 客户端登陆才能使用，所以需要一个<code>连接器</code>来连接用户和 MySQL 数据库，我们一般是使用</p>
<pre><code>mysql -u 用户名 -p 密码</code></pre><p>来进行 MySQL 登陆，和服务端建立连接。在完成 <code>TCP 握手</code> 后，连接器会根据你输入的用户名和密码验证你的登录身份。如果用户名或者密码错误，MySQL 就会提示 <strong>Access denied for user</strong>，来结束执行。如果登录成功后，MySQL 会根据权限表中的记录来判定你的权限。</p>
<h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><p>连接完成后，你就可以执行 SQL 语句了，这行逻辑就会来到第二步：查询缓存。</p>
<p>MySQL 在得到一个执行请求后，会首先去 <code>查询缓存</code> 中查找，是否执行过这条 SQL 语句，之前执行过的语句以及结果会以 <code>key-value</code> 对的形式，被直接放在内存中。key 是查询语句，value 是查询的结果。如果通过 key 能够查找到这条 SQL 语句，就直接返回 SQL 的执行结果。</p>
<p>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果就会被放入查询缓存中。可以看到，如果查询命中缓存，MySQL 不需要执行后面的复杂操作，就可以直接返回结果，效率会很高。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zheroic/zheroic.github.io/images/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdUjIID8CJZm0kCpUTFyVGvJ8ySdarxhtAj94LvDoJuRK8O2MnZ6CzRBbyXDc8Z5vMqRk5GgFb23xg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p><strong>但是查询缓存不建议使用</strong></p>
<p>为什么呢？因为只要在 MySQL 中对某一张表执行了更新操作，那么所有的查询缓存就会失效，对于更新频繁的数据库来说，查询缓存的命中率很低。</p>
<h4 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h4><p>如果没有命中查询，就开始执行真正的 SQL 语句。</p>
<ul>
<li>首先，MySQL 会根据你写的 SQL 语句进行解析，分析器会先做 <code>词法分析</code>，你写的 SQL 就是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串是什么，代表什么。</li>
<li>然后进行 <code>语法分析</code>，根据词法分析的结果， 语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。如果 SQL 语句不正确，就会提示 <strong>You have an error in your SQL syntax</strong></li>
</ul>
<h4 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h4><p>经过分析器的词法分析和语法分析后，你这条 SQL 就<code>合法</code>了，MySQL 就知道你要做什么了。但是在执行前，还需要进行优化器的处理，优化器会判断你使用了哪种索引，使用了何种连接，优化器的作用就是确定效率最高的执行方案。</p>
<h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><p>MySQL 通过分析器知道了你的 SQL 语句是否合法，你想要做什么操作，通过优化器知道了该怎么做效率最高，然后就进入了执行阶段，开始执行这条 SQL 语句</p>
<p>在执行阶段，MySQL 首先会判断你有没有执行这条语句的权限，没有权限的话，就会返回没有权限的错误。如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。对于有索引的表，执行的逻辑也差不多。</p>
<p>至此，MySQL 对于一条语句的执行过程也就完成了。</p>
<h3 id="SQL-的执行顺序"><a href="#SQL-的执行顺序" class="headerlink" title="SQL 的执行顺序"></a>SQL 的执行顺序</h3><p>我们在编写一个查询语句的时候</p>
<pre><code>SELECT DISTINCT    &lt; select_list &gt;FROM    &lt; left_table &gt; &lt; join_type &gt;JOIN &lt; right_table &gt; ON &lt; join_condition &gt;WHERE    &lt; where_condition &gt;GROUP BY    &lt; group_by_list &gt;HAVING    &lt; having_condition &gt;ORDER BY    &lt; order_by_condition &gt;LIMIT &lt; limit_number &gt;</code></pre><p>它的执行顺序你知道吗？这道题就给你一个回答。</p>
<h4 id="FROM-连接"><a href="#FROM-连接" class="headerlink" title="FROM 连接"></a>FROM 连接</h4><p>首先，对 SELECT 语句执行查询时，对<code>FROM</code> 关键字两边的表执行连接，会形成<code>笛卡尔积</code>，这时候会产生一个<code>虚表VT1(virtual table)</code></p>
<blockquote>
<p>“</p>
<p>首先先来解释一下什么是<code>笛卡尔积</code></p>
<p>现在我们有两个集合 A = {0,1} , B = {2,3,4}</p>
<p>那么，集合 A * B 得到的结果就是</p>
<p>A * B = {(0,2)、(1,2)、(0,3)、(1,3)、(0,4)、(1,4)};</p>
<p>B * A = {(2,0)、{2,1}、{3,0}、{3,1}、{4,0}、(4,1)};</p>
<p>上面 A * B 和 B * A 的结果就可以称为两个集合相乘的 <code>笛卡尔积</code></p>
<p>我们可以得出结论，A 集合和 B 集合相乘，包含了集合 A 中的元素和集合 B 中元素之和，也就是 A 元素的个数 * B 元素的个数</p>
</blockquote>
<p>再来解释一下什么是虚表</p>
<blockquote>
<p>“</p>
<p>在 MySQL 中，有三种类型的表</p>
<p>一种是<code>永久表</code>，永久表就是创建以后用来长期保存数据的表</p>
<p>一种是<code>临时表</code>，临时表也有两类，一种是和永久表一样，只保存临时数据，但是能够长久存在的；还有一种是临时创建的，SQL 语句执行完成就会删除。</p>
<p>一种是<code>虚表</code>，虚表其实就是<code>视图</code>，数据可能会来自多张表的执行结果。</p>
</blockquote>
<h4 id="ON-过滤"><a href="#ON-过滤" class="headerlink" title="ON 过滤"></a>ON 过滤</h4><p>然后对 FROM 连接的结果进行 ON 筛选，创建 VT2，把符合记录的条件存在 VT2 中。</p>
<h4 id="JOIN-连接"><a href="#JOIN-连接" class="headerlink" title="JOIN 连接"></a>JOIN 连接</h4><p>第三步，如果是 <code>OUTER JOIN(left join、right join)</code> ，那么这一步就将添加外部行，如果是 left join 就把 ON 过滤条件的左表添加进来，如果是 right join ，就把右表添加进来，从而生成新的虚拟表 VT3。</p>
<h4 id="WHERE-过滤"><a href="#WHERE-过滤" class="headerlink" title="WHERE 过滤"></a>WHERE 过滤</h4><p>第四步，是执行 WHERE 过滤器，对上一步生产的虚拟表引用 WHERE 筛选，生成虚拟表 VT4。</p>
<p>WHERE 和 ON 的区别</p>
<ul>
<li>如果有外部列，ON 针对过滤的是关联表，主表(保留表)会返回所有的列;</li>
<li>如果没有添加外部列，两者的效果是一样的;</li>
</ul>
<p>应用</p>
<ul>
<li>对主表的过滤应该使用 WHERE;</li>
<li>对于关联表，先条件查询后连接则用 ON，先连接后条件查询则用 WHERE;</li>
</ul>
<h4 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h4><p>根据 group by 字句中的列，会对 VT4 中的记录进行分组操作，产生虚拟机表 VT5。果应用了group by，那么后面的所有步骤都只能得到的 VT5 的列或者是聚合函数（count、sum、avg等）。</p>
<h4 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h4><p>紧跟着 GROUP BY 字句后面的是 HAVING，使用 HAVING 过滤，会把符合条件的放在 VT6</p>
<h4 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h4><p>第七步才会执行 SELECT 语句，将 VT6 中的结果按照 SELECT 进行刷选，生成 VT7</p>
<h4 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h4><p>在第八步中，会对 TV7 生成的记录进行去重操作，生成 VT8。事实上如果应用了 group by 子句那么 distinct 是多余的，原因同样在于，分组的时候是将列中唯一的值分成一组，同时只为每一组返回一行记录，那么所以的记录都将是不相同的。</p>
<h4 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h4><p>应用 order by 子句。按照 order_by_condition 排序 VT8，此时返回的一个游标，而不是虚拟表。sql 是基于集合的理论的，集合不会预先对他的行排序，它只是成员的逻辑集合，成员的顺序是无关紧要的。</p>
<p>SQL 语句执行的过程如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/zheroic/zheroic.github.io/images/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdUjIID8CJZm0kCpUTFyVGvJk3dNXRhX7iaSe3hwYebNbtBmic8xcSbJia2y4NA4gmPfezluyBtYMrEAA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<h3 id="什么是临时表，何时删除临时表"><a href="#什么是临时表，何时删除临时表" class="headerlink" title="什么是临时表，何时删除临时表"></a>什么是临时表，何时删除临时表</h3><p>什么是临时表？MySQL 在执行 SQL 语句的过程中，通常会临时创建一些<code>存储中间结果集</code>的表，临时表只对当前连接可见，在连接关闭时，临时表会被删除并释放所有表空间。</p>
<p>临时表分为两种：一种是<code>内存临时表</code>，一种是<code>磁盘临时表</code>，什么区别呢？内存临时表使用的是 MEMORY 存储引擎，而临时表采用的是 MyISAM 存储引擎。</p>
<blockquote>
<p>“</p>
<p>MEMORY 存储引擎：<code>memory</code> 是 MySQL 中一类特殊的存储引擎，它使用存储在内容中的内容来创建表，而且<strong>数据全部放在内存中</strong>。每个基于 MEMORY 存储引擎的表实际对应一个磁盘文件。该文件的文件名与表名相同，类型为 <code>frm</code> 类型。而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。MEMORY 用到的很少，因为它是把数据存到内存中，如果内存出现异常就会影响数据。如果重启或者关机，所有数据都会消失。因此，基于 MEMORY 的表的生命周期很短，一般是一次性的。</p>
</blockquote>
<p>MySQL 会在下面这几种情况产生临时表</p>
<ul>
<li>使用 UNION 查询：UNION 有两种，一种是<code>UNION</code> ，一种是 <code>UNION ALL</code> ，它们都用于联合查询；区别是 使用 UNION 会去掉两个表中的重复数据，相当于对结果集做了一下<code>去重(distinct)</code>。使用 UNION ALL，则不会排重，返回所有的行。使用 UNION 查询会产生临时表。</li>
<li>使用 <code>TEMPTABLE 算法</code>或者是 UNION 查询中的视图。TEMPTABLE 算法是一种创建临时表的算法，它是将结果放置到临时表中，意味这要 MySQL 要先创建好一个临时表，然后将结果放到临时表中去，然后再使用这个临时表进行相应的查询。</li>
<li>ORDER BY 和 GROUP BY 的子句不一样时也会产生临时表。</li>
<li>DISTINCT 查询并且加上 ORDER BY 时；</li>
<li>SQL 用到 SQL_SMALL_RESULT 选项时；如果查询结果比较小的时候，可以加上 SQL_SMALL_RESULT 来优化，产生临时表</li>
<li>FROM 中的子查询；</li>
<li>EXPLAIN 查看执行计划结果的 Extra 列中，如果使用 <code>Using Temporary</code> 就表示会用到临时表。</li>
</ul>
<h3 id="MySQL-常见索引类型"><a href="#MySQL-常见索引类型" class="headerlink" title="MySQL 常见索引类型"></a>MySQL 常见索引类型</h3><p>索引是存储在一张表中特定列上的<code>数据结构</code>，索引是在列上创建的。并且，索引是一种数据结构。</p>
<p>在 MySQL 中，主要有下面这几种索引</p>
<ul>
<li><code>全局索引(FULLTEXT)</code>：全局索引，目前只有 MyISAM 引擎支持全局索引，它的出现是为了解决针对文本的模糊查询效率较低的问题。</li>
<li><code>哈希索引(HASH)</code>：哈希索引是 MySQL 中用到的唯一 key-value 键值对的数据结构，很适合作为索引。HASH 索引具有一次定位的好处，不需要像树那样逐个节点查找，但是这种查找适合应用于查找单个键的情况，对于范围查找，HASH 索引的性能就会很低。</li>
<li><code>B-Tree 索引</code>：B 就是 Balance 的意思，BTree 是一种平衡树，它有很多变种，最常见的就是 B+ Tree，它被 MySQL 广泛使用。</li>
<li><code>R-Tree 索引</code>：R-Tree 在 MySQL 很少使用，仅支持 geometry 数据类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种，相对于 B-Tree 来说，R-Tree 的优势在于范围查找。</li>
</ul>
<h3 id="varchar-和-char-的区别和使用场景"><a href="#varchar-和-char-的区别和使用场景" class="headerlink" title="varchar 和 char 的区别和使用场景"></a>varchar 和 char 的区别和使用场景</h3><p>MySQL 中没有 nvarchar 数据类型，所以直接比较的是 varchar 和 char 的区别</p>
<p><code>char</code> ：表示的是<code>定长</code>的字符串，当你输入小于指定的数目，比如你指定的数目是 <code>char(6)</code>，当你输入小于 6 个字符的时候，char 会在你最后一个字符后面补空值。当你输入超过指定允许最大长度后，MySQL 会报错</p>
<p><img src="https://cdn.jsdelivr.net/gh/zheroic/zheroic.github.io/images/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdUjIID8CJZm0kCpUTFyVGvJm96bLeofaq25BJWSKzfxN0rnAO5YRkibp6NlSMW1b9uEHXxaSEoVbibg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p><code>varchar</code>：varchar 指的是长度为 n 个字节的可变长度，并且是<code>非Unicode</code>的字符数据。n 值是介于 1 - 8000 之间的数值。存储大小为实际大小。</p>
<blockquote>
<p>“</p>
<p>Unicode 是一种字符编码方案，它为每种语言中的每个字符都设定了统一唯一的二进制编码，以实现跨语言、跨平台进行文本转换、处理的要求</p>
</blockquote>
<p>使用 char 存储定长的数据非常方便、char 检索效率高，无论你存储的数据是否到了 10 个字节，都要去占用 10 字节的空间</p>
<p>使用 varchar 可以存储变长的数据，但存储效率没有 char 高。</p>
<h3 id="什么是-内连接、外连接、交叉连接、笛卡尔积"><a href="#什么是-内连接、外连接、交叉连接、笛卡尔积" class="headerlink" title="什么是 内连接、外连接、交叉连接、笛卡尔积"></a>什么是 内连接、外连接、交叉连接、笛卡尔积</h3><p>连接的方式主要有三种：<strong>外连接、内链接、交叉连接</strong></p>
<ul>
<li><p><code>外连接(OUTER JOIN)</code>：外连接分为三种，分别是<code>左外连接(LEFT OUTER JOIN 或 LEFT JOIN)</code> 、<code>右外连接(RIGHT OUTER JOIN 或 RIGHT JOIN)</code> 、<code>全外连接(FULL OUTER JOIN 或 FULL JOIN)</code></p>
<p>左外连接：又称为左连接，这种连接方式会显示左表不符合条件的数据行，右边不符合条件的数据行直接显示 NULL</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zheroic/zheroic.github.io/images/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdUjIID8CJZm0kCpUTFyVGvJvTwOVia8Zk44uShjLiaOQsja6R50xSVTqtQOicsnyQEnCHN1SomT7rw8g/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>  右外连接：也被称为右连接，他与左连接相对，这种连接方式会显示右表不   符合条件的数据行，左表不符合条件的数据行直接显示 NULL</p>
<p><img src="https://cdn.jsdelivr.net/gh/zheroic/zheroic.github.io/images/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdUjIID8CJZm0kCpUTFyVGvJ43jMZbXhMiat3XFuHticHAHXql5ams4liaeoFRDvWnavtNCthnVPrib74Q/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>​    <strong>MySQL 暂不支持全外连接</strong></p>
<ul>
<li><code>内连接(INNER JOIN)</code>：结合两个表中相同的字段，返回关联字段相符的记录。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zheroic/zheroic.github.io/images/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdUjIID8CJZm0kCpUTFyVGvJaS8JOo90Kx1Aic0RBPojqhCjpak7yrUibicaK8pAj6fiaicGzibOZ5hMwLkQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<ul>
<li><code>笛卡尔积(Cartesian product)</code>：我在上面提到了笛卡尔积，为了方便，下面再列出来一下。</li>
</ul>
<blockquote>
<p>“</p>
<p>现在我们有两个集合 A = {0,1} , B = {2,3,4}</p>
<p>那么，集合 A * B 得到的结果就是</p>
<p>A * B = {(0,2)、(1,2)、(0,3)、(1,3)、(0,4)、(1,4)};</p>
<p>B * A = {(2,0)、{2,1}、{3,0}、{3,1}、{4,0}、(4,1)};</p>
<p>上面 A * B 和 B * A 的结果就可以称为两个集合相乘的 <code>笛卡尔积</code></p>
<p>我们可以得出结论，A 集合和 B 集合相乘，包含了集合 A 中的元素和集合 B 中元素之和，也就是 A 元素的个数 * B 元素的个数</p>
</blockquote>
<ul>
<li><p>交叉连接的原文是<code>Cross join</code> ，就是笛卡尔积在 SQL 中的实现，SQL中使用关键字<code>CROSS JOIN</code>来表示交叉连接，在交叉连接中，随便增加一个表的字段，都会对结果造成很大的影响。</p>
<pre><code>SELECT * FROM t_Class a CROSS JOIN t_Student b WHERE a.classid=b.classid</code></pre><p>或者不用 CROSS JOIN，直接用 FROM 也能表示交叉连接的效果</p>
<pre><code>SELECT * FROM t_Class a ,t_Student b WHERE a.classid=b.classid</code></pre><p>如果表中字段比较多，不适宜用交叉连接，交叉连接的效率比较差。</p>
</li>
<li><p>全连接：全连接也就是 <code>full join</code>，MySQL 中不支持全连接，但是可以使用其他连接查询来模拟全连接，可以使用 <code>UNION</code> 和 <code>UNION ALL</code> 进行模拟。例如</p>
<pre><code>(select colum1,colum2...columN from tableA ) union (select colum1,colum2...columN from tableB )

或 (select colum1,colum2...columN from tableA ) union all (select colum1,colum2...columN from tableB )；</code></pre><p>使用 UNION 和 UNION ALL 的注意事项</p>
<blockquote>
<p>“</p>
<p>通过 union 连接的 SQL 分别单独取出的列数必须相同</p>
<p>使用 union 时，多个相等的行将会被合并，由于合并比较耗时，一般不直接使用 union 进行合并，而是通常采用 union all 进行合并</p>
</blockquote>
</li>
</ul>
<h3 id="谈谈-SQL-优化的经验"><a href="#谈谈-SQL-优化的经验" class="headerlink" title="谈谈 SQL 优化的经验"></a>谈谈 SQL 优化的经验</h3><ul>
<li>查询语句无论是使用哪种判断条件 <strong>等于、小于、大于</strong>， <code>WHERE</code> 左侧的条件查询字段不要使用函数或者表达式</li>
<li>使用 <code>EXPLAIN</code> 命令优化你的 SELECT 查询，对于复杂、效率低的 sql 语句，我们通常是使用 explain sql 来分析这条 sql 语句，这样方便我们分析，进行优化。</li>
<li>当你的 SELECT 查询语句只需要使用一条记录时，要使用 <code>LIMIT 1</code></li>
<li>不要直接使用 <code>SELECT *</code>，而应该使用具体需要查询的表字段，因为使用 EXPLAIN 进行分析时，SELECT * 使用的是全表扫描，也就是 <code>type = all</code>。</li>
<li>为每一张表设置一个 ID 属性</li>
<li>避免在 <code>WHERE</code> 字句中对字段进行 <code>NULL</code> 判断</li>
<li>避免在 <code>WHERE</code> 中使用 <code>!=</code> 或 <code>&lt;&gt;</code> 操作符</li>
<li>使用 <code>BETWEEN AND</code> 替代 <code>IN</code></li>
<li>为搜索字段创建索引</li>
<li>选择正确的存储引擎，InnoDB 、MyISAM 、MEMORY 等</li>
<li>使用 <code>LIKE %abc%</code> 不会走索引，而使用 <code>LIKE abc%</code> 会走索引</li>
<li>对于枚举类型的字段(即有固定罗列值的字段)，建议使用<code>ENUM</code>而不是<code>VARCHAR</code>，如性别、星期、类型、类别等</li>
<li>拆分大的 DELETE 或 INSERT 语句</li>
<li>选择合适的字段类型，选择标准是 <strong>尽可能小、尽可能定长、尽可能使用整数</strong>。</li>
<li>字段设计尽可能使用 <code>NOT NULL</code></li>
<li>进行水平切割或者垂直分割</li>
</ul>
<blockquote>
<p>“</p>
<p>水平分割：通过建立结构相同的几张表分别存储数据</p>
<p>垂直分割：将经常一起使用的字段放在一个单独的表中，分割后的表记录之间是一一对应关系。</p>
</blockquote>
<h2 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h2><h3 id="Spark与MR的区别"><a href="#Spark与MR的区别" class="headerlink" title="Spark与MR的区别"></a>Spark与MR的区别</h3><ul>
<li>MR是基于进程，spark是基于线程</li>
<li>Spark的多个task跑在同一个进程上，这个进程会伴随spark应用程序的整个生命周期，即使没有作业进行，进程也是存在的；MR的每一个task都是一个进程，当task完成时，进程也会结束</li>
<li>所以，spark比MR快的原因也在这，MR启动就需要申请资源，用完就销毁，但是spark把进程拿到以后，这个进程会一直存在，即使没有job在跑，所以后边的job可以直接启动，不需要再重新申请资源</li>
<li>速度：spark把运算的中间数据存放在内存，迭代计算效率更高；MR的中间结果需要保存到磁盘，这样必然会有磁盘IO操作，影响性能</li>
<li>容错性：spark容错性高，它通过弹性分布式数据集RDD来实现高效容错，RDD是一组分布式的存储在节点内存中的只读性质的数据集，这些集合是弹性的，某一部分丢失或者出错，可以通过整个数据集的计算流程的血缘关系来实现重建；MR的话容错可能只能重新计算了，成本较高 </li>
<li>适用面：spark更加通用，spark提供了transformation和action这两大类的多个功能的api，另外还有流式处理sparkstreaming模块，图计算GraphX等；MR只提供了map和reduce两种操作，流计算以及其他模块的支持比较缺乏</li>
<li>框架和生态：Spark框架和生态更为复杂，首先由RDD、血缘lineage、执行时的有向无环图DAG、stage划分等等，很多时候spark作业都需要根据不同的业务场景的需要进行调优，以达到性能要求，MR框架及其生态相对较为简单，对性能的要求也相对较弱，但是运行较为稳定，适合长期后台运行 </li>
<li>运行环境：<br>  MR运行在YARN上，<br>  spark：<br>  local：本地运行<br>  standalone：使用Spark自带的资源管理框架，运行spark的应用<br>  yarn：将spark应用类似mr一样，提交到yarn上运行<br>  mesos：类似yarn的一种资源管理框架</li>
</ul>
<h3 id="SparkStreaming"><a href="#SparkStreaming" class="headerlink" title="SparkStreaming"></a>SparkStreaming</h3><h4 id="基本运行原理"><a href="#基本运行原理" class="headerlink" title="基本运行原理"></a>基本运行原理</h4><p>接收实时输入数据流，然后将数据拆分成多个batch，比如每收集5秒的数据封装为一个batch，然后将每个batch交给Spark的计算引擎进行处理，最后会生产出一个结果数据流，其中的数据，也是由一个一个的batch所组成的。</p>
<h3 id="RDD依赖关系与stage划分"><a href="#RDD依赖关系与stage划分" class="headerlink" title="RDD依赖关系与stage划分"></a>RDD依赖关系与stage划分</h3><p>Spark中RDD的高效与DAG图有着莫大的关系，在DAG调度中需要对计算过程划分stage，而划分依据就是RDD之间的依赖关系。</p>
<h4 id="宽依赖窄依赖"><a href="#宽依赖窄依赖" class="headerlink" title="宽依赖窄依赖"></a>宽依赖窄依赖</h4><p>针对不同的转换函数，RDD之间的依赖关系分为窄依赖（narrow dependency）和宽依赖（wide dependency，也成shuffle dependency）。</p>
<ul>
<li>1.1<strong>窄依赖：窄依赖是指1个父RDD分区对应1个子RDD的分区。</strong><br>换句话说，一个父RDD的分区对应于一个子RDD的分区，或者多个父RDD的分区对应于一个子RDD的分区。所以窄依赖又可以分为两种情况：<ul>
<li>1个子RDD的分区对应于1个父RDD的分区，比如map，filter，union等算子</li>
<li>1个子RDD的分区对应于N个父RDD的分区，比如co-partioned join</li>
</ul>
</li>
<li>1.2<strong>宽依赖：宽依赖是指1个父RDD分区对应多个子RDD分区。</strong><br>宽依赖有分为两种情况<ul>
<li>1个父RDD对应非全部多个子RDD分区，比如groupByKey，reduceByKey，sortByKey</li>
<li>1个父RDD对应所有子RDD分区，比如未经协同划分的join<br><img src="https://cdn.jsdelivr.net/gh/zheroic/zheroic.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/zheroic/BlogMedias/images/20200505174723.png" alt=""></li>
</ul>
</li>
</ul>
<p>总结：<strong>如果父RDD分区对应1个子RDD的分区就是窄依赖，否则就是宽依赖。</strong></p>
<h4 id="为什么Spark将依赖分为窄依赖和宽依赖"><a href="#为什么Spark将依赖分为窄依赖和宽依赖" class="headerlink" title="为什么Spark将依赖分为窄依赖和宽依赖"></a>为什么Spark将依赖分为窄依赖和宽依赖</h4><p><strong>1 窄依赖(narrow dependency)：</strong><br>可以支持在同一个集群Executor上，以pipeline管道形式顺序执行多条命令，例如在执行了map后，紧接着执行filter。分区内的计算收敛，不需要依赖所有分区的数据，可以并行地在不同节点进行计算。所以它的失败回复也更有效，因为它只需要重新计算丢失的parent partition即可<br><strong>2 宽依赖(shuffle dependency)：</strong><br>则需要所有的父分区都是可用的，必须等RDD的parent partition数据全部ready之后才能开始计算，可能还需要调用类似MapReduce之类的操作进行跨节点传递。从失败恢复的角度看，shuffle dependency牵涉RDD各级的多个parent partition。</p>
<h4 id="DAG"><a href="#DAG" class="headerlink" title="DAG"></a>DAG</h4><p><strong>RDD之间的依赖关系就形成了DAG（有向无环图）</strong><br>在Spark作业调度系统中，调度的前提是判断多个作业任务的依赖关系，这些作业任务之间可能存在因果的依赖关系，也就是说有些任务必须先获得执行，然后相关的依赖人物才能执行，但是任务之间显然不应出现任何直接或间接的循环依赖关系，所以本质上这种关系适合用DAG表示</p>
<h4 id="stage划分-遇到一个宽依赖就分一个stage"><a href="#stage划分-遇到一个宽依赖就分一个stage" class="headerlink" title="stage划分:遇到一个宽依赖就分一个stage"></a>stage划分:遇到一个宽依赖就分一个stage</h4><p>由于shuffle依赖必须等RDD的父RDD分区数据全部可读之后才能开始计算，因此Spark的设计是让父RDD将结果写在本地，完全写完之后，通知后面的RDD。后面的RDD则首先去读之前RDD的本地数据作为输入，然后进行运算。<br>由于上述特性，讲shuffle依赖就必须分为两个阶段(stage)去做：</p>
<ul>
<li>(1）第1个阶段(stage)需要把结果shuffle到本地，例如reduceByKey，首先要聚合某个key的所有记录，才能进行下一步的reduce计算，这个汇聚的过程就是shuffle。</li>
<li>(2) 第二个阶段(stage)则读入数据进行处理。</li>
</ul>
<h2 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h2><h3 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h3><p>元数据就是表的属性数据，表的名字，列信息，分区等标的属性信息，它是存放在RMDBS传统数据库中的（如，mysql）。</p>
<h3 id="Hive内部表外部表的区别"><a href="#Hive内部表外部表的区别" class="headerlink" title="Hive内部表外部表的区别"></a>Hive内部表外部表的区别</h3><ul>
<li>创建表时：创建内部表时，会将数据移动到数据仓库指向的路径；若创建外部表，仅记录数据所在的路径， 不对数据的位置做任何改变。</li>
<li>删除表时：在删除表的时候，内部表的元数据和数据会被一起删除， 而外部表只删除元数据，不删除数据。这样外部表相对来说更加安全些，数据组织也更加灵活，方便共享源数据。</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr/>

            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            
            
            
            <div class="reprint1">
                <p>
                    <span class="reprint1-tip">
                        <i class="fa fa-exclamation-circle"></i>&nbsp;&nbsp;转载请注明:
                    </span>
                    <a href="https://zheroic.top" class="b-link-green">zheroic's blog</a>
                    <i class="fa fa-angle-right fa-lg fa-fw text-color"></i>
                    <a href="/20200505/20414.html" class="b-link-green">知识整理</a>
                </p>
            </div>

        </div>
    </div>

    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zheroic/zheroic.github.io/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="https://cdn.jsdelivr.net/gh/zheroic/zheroic.github.io/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: '3875e95f58ea59855e05',
        clientSecret: '335bf09bc36a5dae2109909b8b305e96c7966880',
        repo: 'zheroic.github.io',
        owner: 'zheroic',
        admin: "zheroic",
        id: '20200505/20414.html',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/20200506/61661.html">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/zheroic/zheroic.github.io/images/loading.gif" data-original="https://s1.ax1x.com/2020/04/26/JgTYM6.jpg" class="responsive-img" alt="java常见RuntimeException">
                        
                        <span class="card-title">java常见RuntimeException</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            java常见RuntimeException及原因1） java.lang.NullPointerException 空指针异常；出现原因：调用了未经初始化的对象或者是不存在的对象。2） java.lang.ClassNotFoundExc
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2020-05-06
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/java/" class="post-category" target="_blank">
                                    java
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/java/" target="_blank">
                        <span class="chip bg-color">java</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/20200505/19175.html">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/zheroic/zheroic.github.io/images/loading.gif" data-original="https://s1.ax1x.com/2020/04/26/JgTNqO.jpg" class="responsive-img" alt="hadoop-spark-storm的区别">
                        
                        <span class="card-title">hadoop-spark-storm的区别</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Storm与Spark、HadoopStorm与Spark、Hadoop三种框架对比Storm与Spark、Hadoop这三种框架，各有各的优点，每个框架都有自己的最佳应用场景。所以，在不同的应用场景下，应该选择不同的框架。
1.Storm
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2020-05-05
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/spark/" class="post-category" target="_blank">
                                    spark
                                </a>
                            
                            <a href="/categories/spark/storm/" class="post-category" target="_blank">
                                    storm
                                </a>
                            
                            <a href="/categories/spark/storm/hadoop/" class="post-category" target="_blank">
                                    hadoop
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/spark/" target="_blank">
                        <span class="chip bg-color">spark</span>
                    </a>
                    
                    <a href="/tags/hadoop/" target="_blank">
                        <span class="chip bg-color">hadoop</span>
                    </a>
                    
                    <a href="/tags/storm/" target="_blank">
                        <span class="chip bg-color">storm</span>
                    </a>
                    
                    <a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" target="_blank">
                        <span class="chip bg-color">大数据</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: zheroic's blog<br />'
            + '作者: zheroic<br />'
            + '链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/zheroic/zheroic.github.io/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1, h2, h3, h4, h5'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4, h5').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


        <footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            Copyright&copy; 2019 zheroic. 

            <br>
            <span id="sitetime"></span><span class="my-face">ღゝ◡╹)ノ♡</span>
            <br>

            

             
                <span id="busuanzi_container_site_pv"> 
                    <i class="fa fa-heart-o"></i> 
                    本站总访问量 <span id="busuanzi_value_site_pv" class="white-color"></span> 
                    </span> 
                 
                 
                    <span id="busuanzi_container_site_uv"> 
                    人次,&nbsp;访客数 <span id="busuanzi_value_site_uv" class="white-color"></span> 人. </span> 
            


            
                &nbsp; | &nbsp;字数统计:&nbsp;
                <span class="white-color">66.8k</span> 字
            

            
            <br>

        </div>

        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/zheroic" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>


 
    <a href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=13786400418@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>




    <a href="https://zhihu.com/people/132f0470077dbd03ab590f38a775b032" class="tooltipped" target="_blank" data-tooltip="访问我的知乎" data-position="top" data-delay="50">
        <i class="fa fa-inverse">知</i>
    </a>



    <a href="http://wpa.qq.com/msgrd?v=3&uin=2238478733&site=qq&menu=yes" class="tooltipped" target="_blank" data-tooltip="访问我的QQ空间" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>



    <a href="https://weibo.com/6272258190/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo" class="tooltipped" target="_blank" data-tooltip="关注我的微博" data-position="top" data-delay="50">
        <i class="fa fa-weibo"></i>
    </a>



    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fa fa-rss"></i>
    </a>
</div>

    </div>
</footer>

<div class="progress-bar"></div>

<script> 
    $(document).ready(function () { 
        var int = setInterval(fixCount, 50); // 50ms周期检测函数 
        var pvcountOffset = 80000; // 初始化首次数据 
        var uvcountOffset = 20000; 
        function fixCount() { 
            if (document.getElementById("busuanzi_container_site_pv").style.display != "none") {
                    $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + pvcountOffset); 
                    clearInterval(int); 
            } 
            if ($("#busuanzi_container_site_pv").css("display") != "none") { 
                $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + uvcountOffset); // 加上初始数据 
                clearInterval(int); // 停止检测 
                } 
            } 
        });
</script>



<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();

        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */

        var t1 = Date.UTC(2019, 11, 11, 00, 00, 00); //北京时间2019-11-11 00:00:00
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes *
            minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "本站已勉强运行 " + diffYears + " 年 " + diffDays + " 天 " + diffHours +
            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒" ;
    } /*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
    siteTime();
</script>






        <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
        <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


        <script src="https://cdn.jsdelivr.net/gh/zheroic/zheroic.github.io/libs/materialize/materialize.min.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/zheroic/zheroic.github.io/libs/masonry/masonry.pkgd.min.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/zheroic/zheroic.github.io/libs/aos/aos.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/zheroic/zheroic.github.io/libs/scrollprogress/scrollProgress.min.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/zheroic/zheroic.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/zheroic/zheroic.github.io/js/matery.js"></script>

        <!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-164578181-1"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', 'UA-164578181-1');
</script>



        

        
            <script async src="https://cdn.jsdelivr.net/gh/zheroic/zheroic.github.io/libs/others/busuanzi.pure.mini.js"></script>
        

        <!-- 洪卫 shw2018 add 2019.08.28 -->
<!--         <script type="text/javascript">
            var OriginTitile = document.title,
                st;
            document.addEventListener("visibilitychange", function () {
                document.hidden ? (document.title = "看不见我🙈~看不见我🙈~", clearTimeout(st)) : (document.title =
                    "(๑•̀ㅂ•́) ✧被发现了～", st = setTimeout(function () {
                        document.title = OriginTitile
                    }, 3e3))
            })
        </script> -->

         <script type="text/javascript">
            var OriginTitile = document.title,
                st;
            document.addEventListener("visibilitychange", function () {
                document.hidden ? (document.title = OriginTitile, clearTimeout(st)) : (document.title =
                    OriginTitile, st = setTimeout(function () {
                        document.title = OriginTitile
                    }, 3e3))
            })
        </script>

        <!-- 鼠标点击烟花爆炸效果  洪卫 shw2018 add 2019.09.09 -->
        

        <!-- 背景雪花飘落特效洪卫 shw2018 add 2019.09.10 -->
        

        <!-- 鼠标点击文字特效 洪卫 shw2018 add 2019.09.10-->
        
            <script src="/js/wenzi.js" type="text/javascript"></script>
        

        <!-- 背景雪花飘落特效 洪卫 shw2018 add 2019.09.10 -->
        

        <!-- 在线聊天工具  洪卫 shw2018 add 2019.09.11 -->
        

        <!-- 背景 canvas-nest  洪卫 shw 2018  add 2019.09.15-->
        

        <!-- 背景静止彩带  洪卫 shw 2018  add 2019.09.15-->
        

        <!-- 背景动态彩带 洪卫 shw 2018  add 2019.09.15-->
        

        <!-- 天气接口控件 洪卫 shw2018 add 2019.09.09 --> 
         
            <!-- 天气接口 洪卫 shw2018 add 2019.09.09 --> 
<script type="text/javascript"> 
	WIDGET = {FID: 'mxknKNuFj6'} 
</script> 
<!-- <script type="text/javascript" src="https://apip.weatherdt.com/float/static/js/r.js?v=1111"></script> --> 
<script type="text/javascript"> //只在桌面版网页启用特效 
	var windowWidth = $(window).width(); 
	if (windowWidth > 768) { 
		document.write('<script type="text/javascript" src="https://apip.weatherdt.com/float/static/js/r.js?v=1111"><\/script>'); 
	} 
</script>
 
        


    <script>!function(e){var c=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){for(var r=0;r<c.length;r++)t=c[r],0<=(n=t.getBoundingClientRect()).bottom&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=c[r];t=o,n=function(){c=c.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}i(),e.addEventListener("scroll",function(){var t,n;t=i,n=e,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)})}(this);</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script></body>
</html>